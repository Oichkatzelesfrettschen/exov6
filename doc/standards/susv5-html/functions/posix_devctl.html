<!-- Copyright 2001-2024 IEEE and The Open Group, All Rights Reserved -->
<!DOCTYPE HTML>
<html lang="en">
<head>
<meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.8.0">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link type="text/css" rel="stylesheet" href="style.css"><!-- Generated by The Open Group rhtm tool v1.2.4 -->
<!-- Copyright (c) 2001-2024 The Open Group, All Rights Reserved -->
<title>posix_devctl</title>
</head>
<body bgcolor="white">
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/popen.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/posix_fadvise.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>
<hr align="left" width="100%"></div>
<script language="JavaScript" src="../jscript/codes.js"></script><basefont size="3">
<center><font size="2">The Open Group Base Specifications Issue 8<br>
IEEE Std 1003.1-2024<br>
Copyright © 2001-2024 The IEEE and The Open Group</font></center>
<hr size="2" noshade>
<a name="top" id="top"></a> <a name="posix_devctl" id="posix_devctl"></a> <a name="tag_17_380" id="tag_17_380"></a>
<!-- posix_devctl -->
<h4 class="mansect"><a name="tag_17_380_01" id="tag_17_380_01"></a>NAME</h4>
<blockquote>posix_devctl — device control</blockquote>
<h4 class="mansect"><a name="tag_17_380_02" id="tag_17_380_02"></a>SYNOPSIS</h4>
<blockquote class="synopsis">
<div class="box"><code><tt><sup>[<a href="javascript:open_code('DC')">DC</a>]</sup> <img src="../images/opt-start.gif" alt=
"[Option Start]" border="0"> #include &lt;<a href="../basedefs/devctl.h.html">devctl.h</a>&gt;<br>
<br>
int posix_devctl(int</tt> <i>fildes</i><tt>, int</tt> <i>dcmd</i><tt>, void *restrict</tt> <i>dev_data_ptr</i><tt>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t</tt> <i>nbyte</i><tt>, int *restrict</tt> <i>dev_info_ptr</i><tt>); <img src=
"../images/opt-end.gif" alt="[Option End]" border="0"></tt></code></div>
<tt><br></tt></blockquote>
<h4 class="mansect"><a name="tag_17_380_03" id="tag_17_380_03"></a>DESCRIPTION</h4>
<blockquote>
<p>The <i>posix_devctl</i>() function shall cause the device control command <i>dcmd</i> to be passed to the driver identified by
<i>fildes</i>. Associated data shall be passed to and/or from the driver depending on direction information encoded in the
<i>dcmd</i> argument or as implied in the <i>dcmd</i> argument by the design and implementation of the driver.</p>
<p>If the <i>dev_data_ptr</i> argument is not a null pointer, it shall be a pointer to a buffer that is provided by the caller and
that contains data bytes to be passed to the driver or provides space for receiving data bytes to be passed back from the driver,
or both.</p>
<p>If the data bytes are to be passed to the driver, at least <i>nbyte</i> bytes of associated data shall be made available to the
driver; if the data bytes are to be passed from the driver, no more than <i>nbyte</i> bytes shall be passed.</p>
<p>The driver may be executing in an address space different from the address space of the calling thread. Therefore, if the data
bytes passed to the driver (i.e., the contents of the memory area starting at <i>dev_data_ptr</i> and continuing for <i>nbyte</i>
bytes) contain pointers to memory in the address space of the calling thread and the driver uses these pointers to access that
memory, the effects are unspecified.</p>
<p><sup>[<a href="javascript:open_code('OB')">OB</a>]</sup> <img src="../images/opt-start.gif" alt="[Option Start]" border="0"> If
<i>dev_data_ptr</i> is not a null pointer and <i>nbyte</i> is zero, the amount of data passed to and/or from the driver is
unspecified. This feature is obsolescent and is only provided for compatibility with existing device drivers. <img src=
"../images/opt-end.gif" alt="[Option End]" border="0"></p>
<p>If <i>dev_data_ptr</i> is a null pointer, there shall be no data bytes passed between the caller and the driver other than the
data specified in the rest of the arguments to <i>posix_devctl</i>() and in its return value.</p>
<p>The <i>dev_info_ptr</i> argument provides the opportunity to return an integer number containing additional device information,
instead of just a success/failure indication. For implementation-provided <i>dcmd</i> values, it is implementation-defined whether
each such value causes the <b>int</b> pointed to by <i>dev_info_ptr</i> to be set and, if set, what value it is set to.</p>
<p>For each supported device, the set of valid <i>dcmd</i> commands, the associated data interpretation, and the effects of the
command on the device are all defined by the driver for the device identified by <i>fildes</i>, and are therefore
implementation-defined for implementation-provided device drivers.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_380_04" id="tag_17_380_04"></a>RETURN VALUE</h4>
<blockquote>
<p>Upon successful completion, <i>posix_devctl</i>() shall return zero; otherwise an error number shall be returned to indicate the
error. The value returned in the <b>int</b> value pointed to by <i>dev_info_ptr</i> is driver dependent.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_380_05" id="tag_17_380_05"></a>ERRORS</h4>
<blockquote>
<p>The <i>posix_devctl</i>() function shall fail if:</p>
<dl compact>
<dd></dd>
<dt>[EBADF]</dt>
<dd>The <i>fildes</i> argument is not a valid open file descriptor.</dd>
</dl>
<p>The <i>posix_devctl</i>() function may fail if:</p>
<dl compact>
<dd></dd>
<dt>[EINTR]</dt>
<dd>The <i>posix_devctl</i>() function was interrupted by a signal.</dd>
<dt>[EINVAL]</dt>
<dd>The <i>nbyte</i> argument exceeds an implementation-defined maximum or is less than the minimum number of bytes required for
this command.</dd>
<dt>[EINVAL]</dt>
<dd>The <i>dcmd</i> argument is not valid for this device.</dd>
<dt>[ENOTTY]</dt>
<dd>The <i>fildes</i> argument is not associated with a character special file that accepts control functions.</dd>
<dt>[EPERM]</dt>
<dd>The requesting process does not have the appropriate privilege to request the device to perform the specified command.</dd>
</dl>
<p>Driver code may detect other errors, but the error numbers returned are driver dependent. See &quot;Recommended Practice for
Driver-Detected Errors&quot; in RATIONALE.</p>
<p>If the <i>posix_devctl</i>() function fails, the effect of this failed function on the device is driver dependent. Corresponding
data might be transferred, partially transferred, or not transferred at all.</p>
</blockquote>
<hr>
<div class="box"><em>The following sections are informative.</em></div>
<h4 class="mansect"><a name="tag_17_380_06" id="tag_17_380_06"></a>EXAMPLES</h4>
<blockquote>
<p>None.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_380_07" id="tag_17_380_07"></a>APPLICATION USAGE</h4>
<blockquote>
<p>None.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_380_08" id="tag_17_380_08"></a>RATIONALE</h4>
<blockquote>
<h5><a name="tag_17_380_08_01" id="tag_17_380_08_01"></a>Background</h5>
<p>An interface to be included in the POSIX standard should improve source code portability of application programs. In traditional
UNIX practice, <i>ioctl</i>() was used to handle special devices. Therefore, a general specification of its arguments cannot be
written. Based on this fact, in the past many people claimed that <i>ioctl</i>(), or something close to it, had no place in the
POSIX standards.</p>
<p>Against this perception stood the widespread use of <i>ioctl</i>() to interface to all sorts of drivers for a vast variety of
hardware used in all areas of general-purpose, realtime, and embedded computing, such as analog-digital converters, counters, and
video graphic devices. These devices provide a set of services that cannot be represented or used in terms of <a href=
"../functions/read.html"><i>read</i>()</a> or <a href="../functions/write.html"><i>write</i>()</a> calls.</p>
<p>The arguments in favor of <i>ioctl</i>() standardization can be summarized as follows:</p>
<p>Even if <i>ioctl</i>() addresses very different hardware, many of these devices either are actually the same, interfaced to
different computer systems with different implementations of operating systems, or belong to classes of devices with rather high
commonality in their functions, e.g., analog-digital converters or digital-analog converters. Growing standardization of the
control and status register (CSR) space of these devices allows exploitation of a growing similarity of control codes and data for
these devices. A general mechanism is needed to control these devices.</p>
<p>In all these cases, a standardized interface from the application program to drivers for these devices will improve source code
portability.</p>
<p>Even if control codes and device data have to be changed when porting applications from one system to another, the definition of
<i>ioctl</i>() largely improves readability of a program handling special devices. Changes are confined to more clearly labeled
places.</p>
<p>A driver for a specific device normally cannot be considered portable <i>per se</i>, but an application that uses this driver
can be made portable if all interfaces needed are well defined and standardized. Users and integrators of realtime systems often
add device drivers for specific devices, and a standard interface simplifies this process. Also, device drivers often follow their
special hardware from system to system.</p>
<p>In recognition of these reasons, The Open Group included <i>ioctl</i>() in the The Single UNIX Specification, Version 1, and the
interface was later incorporated into POSIX.1 under the XSI STREAMS option (although that option was subsequently removed).</p>
<p>The <i>posix_devctl</i>() interface defined in this standard provides an alternative to the the various <i>ioctl</i>()
implementations with a standard interface that captures the extensibility of <i>ioctl</i>(), but avoids several of its
deficiencies, which is mentioned in &quot;Relationship to <i>ioctl</i>() and the Perceived Needs for Improvement&quot; below.</p>
<h5><a name="tag_17_380_08_02" id="tag_17_380_08_02"></a>Existing Practice</h5>
<p>The <i>ioctl</i>() interface is widely used. It has provided the generality mentioned above. Existing practice encodes into the
second parameter information about data size and direction in some systems. An example of such an encoding is the use in BSD 4.3 of
two bits of the command word as read/write bits. However, <i>ioctl</i>() has definite problems with the way that its sometimes
optional third parameter can be interpreted.</p>
<p>This practice is similar to the existing POSIX <a href="../functions/fcntl.html"><i>fcntl</i>()</a> function, in which the third
parameter can be optional for the F_GETFD and F_GETFL commands, an <b>int</b> when used with the F_DUPFD, F_SETFD, or F_SETFL
commands, or a <b>struct flock</b> when used with the F_GETLK, F_SETLK, or F_SETLKW commands. However, the <a href=
"../functions/fcntl.html"><i>fcntl</i>()</a> interface defines two distinct and known data types as possible for the third
parameter. This is not the case in the <i>ioctl</i>() interface, where any number of device driver specific structures and commands
are used.</p>
<h5><a name="tag_17_380_08_03" id="tag_17_380_08_03"></a>Relationship to ioctl() and the Perceived Needs for Improvement</h5>
<p><a href="../xrat/V4_xbd_chap01.html#tag_21_11"><i>A.11 General Terminal Interface</i></a> briefly mentions some of the perceived
deficiencies in existing implementations of the <i>ioctl</i>() function, in the context of those <i>ioctl</i>() commands used to
implement terminal control. The standard developers decided that, since the set of such control operations was fairly well defined,
suitable encapsulations such as <a href="../functions/tcsetattr.html"><i>tcsetattr</i>()</a>, <a href=
"../functions/tcsendbreak.html"><i>tcsendbreak</i>()</a>, and <a href="../functions/tcdrain.html"><i>tcdrain</i>()</a> could be
standardized. These interfaces, while successfully standardizing portable terminal control operations, are not extensible to
arbitrary user-supplied devices.</p>
<p>There are several perceived deficiencies with the <i>ioctl</i>() function that drove the development of the
<i>posix_devctl</i>() interface as an alternative:</p>
<ul>
<li>
<p>The major problem with <i>ioctl</i>() is that the third argument (when one is passed) varies in both size and type according to
the second (command) argument. It is not unprecedented in POSIX, or standards in general, for a function to accept a generic
pointer; consider the ISO C function <a href="../functions/fread.html"><i>fread</i>()</a>, or the POSIX functions <a href=
"../functions/read.html"><i>read</i>()</a> and <a href="../functions/mmap.html"><i>mmap</i>()</a>. However, in all such instances,
the generic pointer is accompanied by a size argument that specifies the size of the pointed-to object. Unlike the Ada language, it
is, and has always been, the C programmer's responsibility to ensure that these two arguments form a consistent specification of
the passed object. But traditional <i>ioctl</i>() implementations do not allow the user to specify the size of the pointed-to
object; that size is instead fixed implicitly by the specified command (passed as another argument). The <i>posix_devctl</i>()
interface improves upon <i>ioctl</i>() in that it allows the user to specify the object size, thereby restoring the familiar C
paradigm for passing a generic object by pointer/size pair.</p>
</li>
<li>
<p>A secondary problem with <i>ioctl</i>() is that the third argument is sometimes permitted to be interpreted as an integer
(<b>int</b>). The <i>posix_devctl</i>() interface clearly requires the <i>dev_data_ptr</i> argument to be a pointer.</p>
</li>
<li>
<p>A related problem with <i>ioctl</i>() is that the direction(s) in which data are transferred to or from the pointed-to object is
neither specified explicitly as an argument (as with <a href="../functions/mmap.html"><i>mmap</i>()</a>), nor implied by the
<i>ioctl</i>() function (as with <a href="../functions/read.html"><i>read</i>()</a>/<a href=
"../functions/write.html"><i>write</i>()</a>, <a href="../functions/fread.html"><i>fread</i>()</a>/<a href=
"../functions/fwrite.html"><i>fwrite</i>()</a>, or <a href="../functions/fgets.html"><i>fgets</i>()</a>/<a href=
"../functions/fputs.html"><i>fputs</i>()</a>). Instead, the direction is implied by the command argument. In traditional
implementations, only the device driver knows the interpretation of the commands and whether data bytes are to be transferred to or
from the pointed-to object. But in networked implementations, generic portions of the operating system may need to know the
direction to ensure that data bytes are passed properly between a client and a server, separately from device driver concerns. Two
implementation-specific solutions to this problem are to always assume data bytes need to be transferred in both directions, or to
encode the implied direction into the command word along with the fixed data size. The <i>posix_devctl</i>() interface already
provides the implementation with an explicit size parameter. Since the direction is already known implicitly to both the
application and the driver and since workable methods exist for implementations to ascertain that direction if required, this
perceived problem is strictly an implementation issue and solvable without further impact on the interface.</p>
</li>
<li>
<p>Finally, <i>posix_devctl</i>() improves upon <i>ioctl</i>() by adopting the new style of error return, avoiding all the problems
<i>errno</i> brings to multi-threaded applications. Because the driver-specific information carried by the non-error return values
of <i>ioctl</i>() still potentially needs to be passed to the application, <i>posix_devctl</i>() adds the <i>dev_info_ptr</i>
argument to specify where this information should be stored.</p>
</li>
</ul>
<h5><a name="tag_17_380_08_04" id="tag_17_380_08_04"></a>Which Differences Between posix_devctl() and ioctl() Are Acceptable?</h5>
<p>Any differences between the definitions of <i>posix_devctl</i>() and <i>ioctl</i>() have to be perceived as a clear improvement
by the community of potential users. Drivers for normal peripherals are typically written by highly specialized professionals.
Drivers for the special devices are very often written by the application developer or by the hardware designer. Any interface
definition that can be seen as overly complicated will simply not be accepted.</p>
<p>Nevertheless, a few simple and useful improvements to <i>ioctl</i>() are possible, specifically the improvement of type
checking, and justify the definition of a new interface.</p>
<p>The major difference between the two interfaces is the addition of the size of the device data. For enhanced compatibility with
existing <i>ioctl</i>() implementations, this size can be specified as zero; in this case the amount of data passed is unspecified.
(This allows a macro definition of <i>ioctl</i>() that converts it into a <i>posix_devctl</i>() call.) In any case, the data size
argument does not contradict the general goal of being able to implement <i>posix_devctl</i>() using the existing <i>ioctl</i>()
interfaces provided in current UNIX systems and other POSIX implementations because the standard allows but does not require
checking the size of the device data. Although the third argument of the <i>ioctl</i>() function does not specify a size, it is
implicit in the specific combination of control command and driver and, therefore, known to the driver implementation.</p>
<p>The method of indicating error return values differs from traditional <i>ioctl</i>() implementations, but it does not preclude
the construction of <i>posix_devctl</i>() as a macro built upon <i>ioctl</i>(), which was one of the original design goals.</p>
<h5><a name="tag_17_380_08_05" id="tag_17_380_08_05"></a>Rationale for the dev_info_ptr Argument</h5>
<p>The POSIX.26 developers felt that it was important to preserve the current <i>ioctl</i>() functionality of allowing a device
driver to return some arbitrary piece of information instead of just a success/failure indication. Such information might be, for
example, the number of bytes received, the number of bytes that would not fit into the buffer pointed at by <i>dev_data_ptr</i>,
the data type indication, or the device status. Current practice for device drivers and <i>ioctl</i>() usage allows such a
device-dependent return value. Thus, the concept of an additional output argument, <i>dev_info_ptr</i>, was born.</p>
<h5><a name="tag_17_380_08_06" id="tag_17_380_08_06"></a>Rationale for No direction Argument</h5>
<p>The initial specification for <i>posix_devctl</i>() contained an additional argument that specified the direction of data flow,
i.e., to the driver and/or from the driver. This argument was later removed for the following reasons:</p>
<ul>
<li>
<p>The argument was redundant. Most (if not all) existing implementations encode the direction data either explicitly or implicitly
in the command word.</p>
</li>
<li>
<p>The argument increased the probability of programming errors, since it must be made to agree with the direction information
already encoded or implied in the command word or an error would occur.</p>
</li>
<li>
<p>The only real use of the argument would be if new drivers were written that supported generic commands such as
TRANSFER_CONTROL_DATA, which was modified by the direction argument to indicate in which direction the data should be transferred.
This is contrary to current practice that uses command pairs such as GET_CONTROL_DATA and PUT_CONTROL_DATA.</p>
</li>
<li>
<p>The primary purpose of the direction argument was to allow higher levels of the system to identify the direction of data
transfers, particularly in the case of remote devices, without having to understand all the commands of all the devices on the
system. Implementations that need to ascertain the direction of data transfer from a command word will define a consistent
convention for encoding the direction into each command word, and all device drivers supplied by the user must adhere to this
convention.</p>
</li>
</ul>
<p>Thus, the data direction argument was removed.</p>
<h5><a name="tag_17_380_08_07" id="tag_17_380_08_07"></a>Rationale for Not Defining the Direction Encoding in the dcmd
Argument</h5>
<p>The POSIX.26 developers gave consideration to defining the direction encoding in the <i>dcmd</i> argument, but decided against
doing so. No particular benefit was seen to a predefined encoding, as long as the encoding was used consistently across the entire
implementation and was well known to the implementation.</p>
<p>In addition, although only one encoding (BSD's) employed for <i>ioctl</i>() was known among the members of the small working
group, it could not be ruled out that other encodings already existed, and no reason for precluding these encodings was seen.</p>
<p>Finally, system or architectural constraints might make a chosen standard encoding difficult to use on a given
implementation.</p>
<p>Thus, this standard does not define a direction encoding. Specifying a standard encoding is actually a small part of a larger
and more contentious objective, that of specifying a complete set of interfaces for portable device drivers. If a future POSIX
standard specifies such interfaces, the issue of device control direction encoding will necessarily be addressed as part of that
specification.</p>
<h5><a name="tag_17_380_08_08" id="tag_17_380_08_08"></a>Recommended Practice for Handling Data Size Errors</h5>
<p>In the event that the amount of data from the device is too large to fit into the specified buffer, as much data as will fit
should be transferred, and the error posted. The retained data will aid in debugging, even if some of the data is lost.</p>
<h5><a name="tag_17_380_08_09" id="tag_17_380_08_09"></a>Recommended Practice for nbyte == 0</h5>
<p>The feature that permits an unspecified amount of control data to be transferred if <i>nbyte</i> is zero exists only for
compatibility with existing device driver usage of <i>ioctl</i>(), i.e., when <i>ioctl</i>() is implemented on top of
<i>posix_devctl</i>() and the device driver transfers an amount of data implied by the command.</p>
<p>Implementations in which <i>posix_devctl</i>() is built as a library routine on top of <i>ioctl</i>() may not be able to make
checks on the <i>nbyte</i> argument. However, newly developed applications using <i>posix_devctl</i>() should always use an
appropriate value for the <i>nbyte</i> argument, for portability to implementations directly supporting <i>posix_devctl</i>() in
which the device drivers may be able to honor the application's <i>nbyte</i> argument or return the error [EINVAL] if the argument
is an unacceptable value. Device drivers designed for those systems should interpret a zero value of <i>nbyte</i> as no data to be
transferred.</p>
<h5><a name="tag_17_380_08_10" id="tag_17_380_08_10"></a>Recommended Practice for Driver-Detected Errors</h5>
<p>If the driver detects the following error conditions, it is recommended that the <i>posix_devctl</i>() function fail and return
the corresponding error number:</p>
<dl compact>
<dd></dd>
<dt>[EBUSY]</dt>
<dd>The control operation could not complete successfully because the device was in use by another process, or the driver was
unable to carry out the request due to an outstanding operation in progress.</dd>
<dt>[EINVAL]</dt>
<dd>The arguments <i>dev_data_ptr</i> and <i>nbyte</i> define a buffer too small to hold the amount of data expected by or to be
returned by this driver.</dd>
<dt>[EIO]</dt>
<dd>The control operation could not complete successfully because the driver detected a hardware error.</dd>
</dl>
</blockquote>
<h4 class="mansect"><a name="tag_17_380_09" id="tag_17_380_09"></a>FUTURE DIRECTIONS</h4>
<blockquote>
<p>None.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_380_10" id="tag_17_380_10"></a>SEE ALSO</h4>
<blockquote>
<p>XBD <a href="../basedefs/V1_chap04.html#tag_04_21"><i>4.21 Special Device Drivers</i></a>, <a href=
"../basedefs/devctl.h.html"><i>&lt;devctl.h&gt;</i></a></p>
</blockquote>
<h4 class="mansect"><a name="tag_17_380_11" id="tag_17_380_11"></a>CHANGE HISTORY</h4>
<blockquote>
<p>First released in Issue 8. Derived from POSIX.26.</p>
</blockquote>
<div class="box"><em>End of informative text.</em></div>
<hr>
<p>&nbsp;</p>
<a href="#top"><span class="topOfPage">return to top of page</span></a><br>
<hr size="2" noshade>
<center><font size="2">UNIX® is a registered Trademark of The Open Group.<br>
POSIX™ is a Trademark of The IEEE.<br>
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved<br>
[ <a href="../mindex.html">Main Index</a> | <a href="../basedefs/contents.html">XBD</a> | <a href=
"../functions/contents.html">XSH</a> | <a href="../utilities/contents.html">XCU</a> | <a href="../xrat/contents.html">XRAT</a>
]</font></center>
<hr size="2" noshade>
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/popen.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/posix_fadvise.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>
<hr align="left" width="100%"></div>
</body>
</html>
