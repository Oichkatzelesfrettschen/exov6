<!-- Copyright 2001-2024 IEEE and The Open Group, All Rights Reserved -->
<!DOCTYPE HTML>
<html lang="en">
<head>
<meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.8.0">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link type="text/css" rel="stylesheet" href="style.css"><!-- Generated by The Open Group rhtm tool v1.2.4 -->
<!-- Copyright (c) 2001-2024 The Open Group, All Rights Reserved -->
<title>close</title>
</head>
<body bgcolor="white">
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/clog.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/closedir.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>
<hr align="left" width="100%"></div>
<script language="JavaScript" src="../jscript/codes.js"></script><basefont size="3">
<center><font size="2">The Open Group Base Specifications Issue 8<br>
IEEE Std 1003.1-2024<br>
Copyright © 2001-2024 The IEEE and The Open Group</font></center>
<hr size="2" noshade>
<a name="top" id="top"></a> <a name="close" id="close"></a> <a name="tag_17_81" id="tag_17_81"></a><!-- close -->
<h4 class="mansect"><a name="tag_17_81_01" id="tag_17_81_01"></a>NAME</h4>
<blockquote>close, posix_close — close a file descriptor</blockquote>
<h4 class="mansect"><a name="tag_17_81_02" id="tag_17_81_02"></a>SYNOPSIS</h4>
<blockquote class="synopsis">
<p><code><tt>#include &lt;<a href="../basedefs/unistd.h.html">unistd.h</a>&gt;<br>
<br>
int close(int</tt> <i>fildes</i><tt>);<br>
int posix_close(int</tt> <i>fildes</i><tt>, int</tt> <i>flag</i><tt>);<br></tt></code></p>
</blockquote>
<h4 class="mansect"><a name="tag_17_81_03" id="tag_17_81_03"></a>DESCRIPTION</h4>
<blockquote>
<p>The <i>close</i>() function shall deallocate the file descriptor indicated by <i>fildes</i>. To deallocate means to make the
file descriptor available for return by subsequent calls to <a href="../functions/open.html"><i>open</i>()</a> or other functions
that allocate file descriptors. All process-owned file locks that the calling process owns on the file associated with the file
descriptor shall be unlocked.</p>
<p>If <i>close</i>() is interrupted by a signal that is to be caught, then it is unspecified whether it returns -1 with
<i>errno</i> set to [EINTR] and <i>fildes</i> remaining open, or returns -1 with <i>errno</i> set to [EINPROGRESS] and
<i>fildes</i> being closed, or returns 0 to indicate successful completion; except that if POSIX_CLOSE_RESTART is defined as 0,
then the option of returning -1 with <i>errno</i> set to [EINTR] and <i>fildes</i> remaining open shall not occur. If
<i>close</i>() returns -1 with <i>errno</i> set to [EINTR], it is unspecified whether <i>fildes</i> can subsequently be passed to
any function except <i>close</i>() or <i>posix_close</i>() without error. For all other error situations (except for [EBADF] where
<i>fildes</i> was invalid), <i>fildes</i> shall be closed. If <i>fildes</i> was closed even though the close operation is
incomplete, the close operation shall continue asynchronously and the process shall have no further ability to track the completion
or final status of the close operation.</p>
<p>When all file descriptors associated with a pipe or FIFO special file are closed, any data remaining in the pipe or FIFO shall
be discarded.</p>
<p>When all file descriptors associated with an open file description have been closed, the open file description shall be
freed.</p>
<p>If the link count of the file is 0, when all file descriptors associated with the file are closed, the space occupied by the
file shall be freed and the file shall no longer be accessible.</p>
<p><sup>[<a href="javascript:open_code('XSI')">XSI</a>]</sup> <img src="../images/opt-start.gif" alt="[Option Start]" border="0">
If <i>fildes</i> refers to the manager side of a pseudo-terminal, and this is the last close, a SIGHUP signal shall be sent to the
controlling process, if any, for which the subsidiary side of the pseudo-terminal is the controlling terminal. It is unspecified
whether closing the manager side of the pseudo-terminal flushes all queued input and output. <img src="../images/opt-end.gif" alt=
"[Option End]" border="0"></p>
<p>When there is an outstanding cancelable asynchronous I/O operation against <i>fildes</i> when <i>close</i>() is called, that I/O
operation may be canceled. An I/O operation that is not canceled completes as if the <i>close</i>() operation had not yet occurred.
All operations that are not canceled shall complete as if the <i>close</i>() blocked until the operations completed. The
<i>close</i>() operation itself need not block awaiting such I/O completion. Whether any I/O operation is canceled, and which I/O
operation may be canceled upon <i>close</i>(), is implementation-defined.</p>
<p>If a memory mapped file <sup>[<a href="javascript:open_code('SHM')">SHM</a>]</sup> <img src="../images/opt-start.gif" alt=
"[Option Start]" border="0"> &nbsp;or a shared memory object <img src="../images/opt-end.gif" alt="[Option End]" border="0">
&nbsp;remains referenced at the last close (that is, a process has it mapped), then the entire contents of the memory object shall
persist until the memory object becomes unreferenced. If this is the last close of a memory mapped file <sup>[<a href=
"javascript:open_code('SHM')">SHM</a>]</sup> <img src="../images/opt-start.gif" alt="[Option Start]" border="0"> &nbsp;or a shared
memory object <img src="../images/opt-end.gif" alt="[Option End]" border="0"> &nbsp;and the close results in the memory object
becoming unreferenced, and the memory object has been unlinked, then the memory object shall be removed.</p>
<p>When all file descriptors associated with a socket have been closed, the socket shall be destroyed. If the socket is in
connection-mode, and the SO_LINGER option is set for the socket with non-zero linger time, and the socket has untransmitted data,
then <i>close</i>() shall block for up to the current linger interval until all data is transmitted.</p>
<p>The <i>posix_close</i>() function shall be equivalent to the <i>close</i>() function, except with the modifications based on the
<i>flag</i> argument as described below. If <i>flag</i> is 0, then <i>posix_close</i>() shall not return -1 with <i>errno</i> set
to [EINTR], which implies that <i>fildes</i> will always be closed (except for [EBADF], where <i>fildes</i> was invalid). If
<i>flag</i> includes POSIX_CLOSE_RESTART and POSIX_CLOSE_RESTART is defined as a non-zero value, and <i>posix_close</i>() is
interrupted by a signal that is to be caught, then <i>posix_close</i>() may return -1 with <i>errno</i> set to [EINTR], in which
case <i>fildes</i> shall be left open; however, it is unspecified whether <i>fildes</i> can subsequently be passed to any function
except <i>close</i>() or <i>posix_close</i>() without error. If <i>flag</i> is invalid, <i>posix_close</i>() may fail with errno
set to [EINVAL], but shall otherwise behave as if <i>flag</i> had been 0 and close <i>fildes</i>.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_81_04" id="tag_17_81_04"></a>RETURN VALUE</h4>
<blockquote>
<p>Upon successful completion, 0 shall be returned; otherwise, -1 shall be returned and <i>errno</i> set to indicate the error.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_81_05" id="tag_17_81_05"></a>ERRORS</h4>
<blockquote>
<p>The <i>close</i>() and <i>posix_close</i>() functions shall fail if:</p>
<dl compact>
<dd></dd>
<dt>[EBADF]</dt>
<dd>The <i>fildes</i> argument is not a open file descriptor.</dd>
<dt>[EINPROGRESS]</dt>
<dd>The function was interrupted by a signal and <i>fildes</i> was closed but the close operation is continuing
asynchronously.</dd>
</dl>
<p>The <i>close</i>() and <i>posix_close</i>() functions may fail if:</p>
<dl compact>
<dd></dd>
<dt>[EINTR]</dt>
<dd>The function was interrupted by a signal, POSIX_CLOSE_RESTART is defined as non-zero, and (in the case of <i>posix_close</i>())
the <i>flag</i> argument included POSIX_CLOSE_RESTART, in which case <i>fildes</i> is still open.</dd>
<dt>[EIO]</dt>
<dd>An I/O error occurred while reading from or writing to the file system.</dd>
</dl>
<p>The <i>posix_close</i>() function may fail if:</p>
<dl compact>
<dd></dd>
<dt>[EINVAL]</dt>
<dd>The value of the <i>flag</i> argument is invalid.</dd>
</dl>
<p>The <i>close</i>() and <i>posix_close</i>() functions shall not return an [EAGAIN] or [EWOULDBLOCK] error. If
POSIX_CLOSE_RESTART is zero, the <i>close</i>() function shall not return an [EINTR] error. The <i>posix_close</i>() function shall
not return an [EINTR] error unless <i>flag</i> includes a non-zero POSIX_CLOSE_RESTART.</p>
</blockquote>
<hr>
<div class="box"><em>The following sections are informative.</em></div>
<h4 class="mansect"><a name="tag_17_81_06" id="tag_17_81_06"></a>EXAMPLES</h4>
<blockquote>
<h5><a name="tag_17_81_06_01" id="tag_17_81_06_01"></a>Reassigning a File Descriptor</h5>
<p>The following example closes the file descriptor associated with standard output for the current process, re-assigns standard
output to a new file descriptor, and closes the original file descriptor to clean up. This example assumes that the file descriptor
0 (which is the descriptor for standard input) is not closed.</p>
<pre>
<tt>#include &lt;unistd.h&gt;
...
int pfd;
...
close(1);
dup(pfd);
close(pfd);
...
</tt></pre>
<p>Incidentally, this is exactly what could be achieved using:</p>
<pre>
<tt>dup2(pfd, 1);
close(pfd);
</tt></pre>
<h5><a name="tag_17_81_06_02" id="tag_17_81_06_02"></a>Closing a File Descriptor</h5>
<p>In the following example, <i>close</i>() is used to close a file descriptor after an unsuccessful attempt is made to associate
that file descriptor with a stream.</p>
<pre>
<tt>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
<br>
#define LOCKFILE "/etc/ptmp"
...
int pfd;
FILE *fpfd;
...
if ((fpfd = fdopen (pfd, "w")) == NULL) {
    close(pfd);
    unlink(LOCKFILE);
    exit(1);
}
...
</tt></pre></blockquote>
<h4 class="mansect"><a name="tag_17_81_07" id="tag_17_81_07"></a>APPLICATION USAGE</h4>
<blockquote>
<p>An application that had used the <i>stdio</i> routine <a href="../functions/fopen.html"><i>fopen</i>()</a> to open a file should
use the corresponding <a href="../functions/fclose.html"><i>fclose</i>()</a> routine rather than <i>close</i>(). Once a file is
closed, the file descriptor no longer exists, since the integer corresponding to it no longer refers to a file.</p>
<p>Implementations may use file descriptors that must be inherited into child processes for the child process to remain conforming,
such as for message catalog or tracing purposes. Therefore, an application that calls <i>close</i>() on an arbitrary integer risks
non-conforming behavior, and <i>close</i>() can only portably be used on file descriptor values that the application has obtained
through explicit actions, as well as the three file descriptors corresponding to the standard file streams. In multi-threaded
parent applications, the practice of calling <i>close</i>() in a loop after <a href="../functions/fork.html"><i>fork</i>()</a> and
before an <i><a href="../functions/exec.html">exec</a></i> call in order to avoid a race condition of leaking an unintended file
descriptor into a child process, is therefore unsafe, and the race should instead be combatted by opening all file descriptors with
the FD_CLOEXEC bit set unless the file descriptor is intended to be inherited across <i><a href=
"../functions/exec.html">exec</a></i>.</p>
<p>Usage of <i>close</i>() on file descriptors STDIN_FILENO, STDOUT_FILENO, or STDERR_FILENO should immediately be followed by an
operation to reopen these file descriptors. Unexpected behavior will result if any of these file descriptors is left in a closed
state (for example, an [EBADF] error from <a href="../functions/perror.html"><i>perror</i>()</a>) or if an unrelated <a href=
"../functions/open.html"><i>open</i>()</a> or similar call later in the application accidentally allocates a file to one of these
well-known file descriptors. Furthermore, a <i>close</i>() followed by a reopen operation (e.g., <a href=
"../functions/open.html"><i>open</i>()</a>, <a href="../functions/dup.html"><i>dup</i>()</a>, etc.) is not atomic; <a href=
"../functions/dup2.html"><i>dup2</i>()</a> should be used to change standard file descriptors.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_81_08" id="tag_17_81_08"></a>RATIONALE</h4>
<blockquote>
<p>The use of interruptible device close routines should be discouraged to avoid problems with the implicit closes of file
descriptors, such as by <i><a href="../functions/exec.html">exec</a></i>, process termination, or <a href=
"../functions/dup2.html"><i>dup2</i>()</a>. This volume of POSIX.1-2024 only intends to permit such behavior by specifying the
[EINTR] error condition for <i>close</i>() and <i>posix_close</i>() with non-zero POSIX_CLOSE_RESTART, to allow applications a
portable way to resume waiting for an event associated with the close operation (for example, a tape drive rewinding) after
receiving an interrupt. This standard also permits implementations to define POSIX_CLOSE_RESTART to 0 if they do not choose to
provide a way to restart an interrupted close action. Although the file descriptor is left open on [EINTR], it might no longer be
usable; that is, passing it to any function except <i>close</i>() or <i>posix_close</i>() might result in an error such as [EIO].
If an application must guarantee that data will not be lost, it is recommended that the application use <a href=
"../functions/fsync.html"><i>fsync</i>()</a> or <a href="../functions/fdatasync.html"><i>fdatasync</i>()</a> prior to the close
operation, rather than leaving the close operation to deal with pending I/O and risk an interrupt.</p>
<p>Earlier versions of this standard left the state of <i>fildes</i> unspecified after errors such as [EINTR] and [EIO]; and
implementations differed on whether <i>close</i>() left <i>fildes</i> open after [EINTR]. This was unsatisfactory once threads were
introduced, since multi-threaded applications need to know whether <i>fildes</i> has been closed. Applications cannot blindly call
<i>close</i>() again, because if <i>fildes</i> was closed by the first call another thread could have been allocated a file
descriptor with the same value as <i>fildes</i>, which must not be closed by the first thread. On the other hand, the alternative
of never retrying <i>close</i>() would lead to a file descriptor leak in implementations where <i>close</i>() did not close
<i>fildes</i>, although such a leak may be harmless if the process is about to exit or the file descriptor is marked FD_CLOEXEC and
the process is about to be replaced by <i><a href="../functions/exec.html">exec</a></i>. This standard introduced
<i>posix_close</i>() with a <i>flag</i> argument that allows a choice between the two possible error behaviors, and leaves it
unspecified which of the two behaviors is implemented by <i>close</i>() (although it is guaranteed to be one of the two behaviors
of <i>posix_close</i>(), rather than leaving things completely unspecified as in earlier versions of the standard).</p>
<p>Note that the standard requires that <i>close</i>() and <i>posix_close</i>() must leave <i>fildes</i> open after [EINTR] (in the
cases where [EINTR] is permitted) and must close the file descriptor regardless of all other errors (except [EBADF], where
<i>fildes</i> is already invalid). In general, portable applications should only retry a <i>close</i>() after checking for [EINTR]
(and on implementations where POSIX_CLOSE_RESTART is defined to be zero, this retry loop will be dead code), and risk a file
descriptor leak if a retry loop is not attempted. It should also be noted that [EINTR] is only possible if <i>close</i>() can be
interrupted; if no signal handlers are installed, then <i>close</i>() will not be interrupted. Conversely, if a single-threaded
application can guarantee that no file descriptors are opened or closed in signal handlers, then a retry loop without checking for
[EINTR] will be harmless (since the retry will fail with [EBADF]), but guaranteeing that no external libraries introduce the use of
threading can be difficult. There are additional guarantees for applications which will only ever be used on systems where
POSIX_CLOSE_RESTART is defined as 0. These observations should help in determining whether an application needs to have its
<i>close</i>() calls audited for replacement with <i>posix_close</i>().</p>
<p>It should also be noted that the requirement for <i>posix_close</i>() with a <i>flag</i> of 0 to always close <i>fildes</i>,
even if an error is reported, is similar to the requirements on <a href="../functions/fclose.html"><i>fclose</i>()</a> to always
release the stream, even if an error is encountered while flushing data.</p>
<p>Implementations that previously always closed <i>fildes</i> can meet the new requirements by translating [EINTR] to
[EINPROGRESS] in <i>close</i>(); and may define POSIX_CLOSE_RESTART to 0 rather than having to add restart semantics. On the other
hand, implementations that previously left <i>fildes</i> open on [EINTR] can map that to <i>posix_close</i>() with
POSIX_CLOSE_RESTART, and must add the semantics of <i>posix_close</i>() when <i>flag</i> is 0; one possibility is by calling the
original <i>close</i>() implementation, checking for failure, and on [EINTR], using actions similar to <a href=
"../functions/dup2.html"><i>dup2</i>()</a> to replace the incomplete close operation with another file descriptor that can be
closed immediately by another call to the original <i>close</i>(), all before returning to the application. Either way,
<i>close</i>() should always map to one of the two behaviors of <i>posix_close</i>(), and implementations are encouraged to keep
the behavior of <i>close</i>() unchanged so as not to break implementation-specific expectations of older applications that were
relying on behavior not specified by older versions of this standard.</p>
<p>The standard developers considered introducing a thread-local variable that <i>close</i>() would set to indicate whether it had
closed <i>fildes</i> when returning -1. However, this was rejected in favor of the simpler solution of tightening <i>close</i>() to
guarantee that <i>fildes</i> is closed except for [EINTR], and exposing a choice of whether to expect [EINTR] by adding
<i>posix_close</i>(). Additionally, while the name <i>posix_close</i>() is new to this standard, it is reminiscent of at least one
implementation that introduced an alternate system call named <i>close_nocancel</i>() in order to allow an application to choose
whether restart semantics were desired.</p>
<p>Another consideration was whether implementations might return [EAGAIN] as an extension and whether <i>close</i>() should be
required to leave the file descriptor open in this case, since [EAGAIN] normally implies an operation should be retried. It seemed
very unlikely that any implementation would have a legitimate reason to return [EAGAIN] or [EWOULDBLOCK], and therefore this
requirement would mean applications have to include code for an error case that will never be used. Therefore <i>close</i>() is now
forbidden from returning [EAGAIN] and [EWOULDBLOCK] errors.</p>
<p>Note that the requirement for <i>close</i>() on a socket to block for up to the current linger interval is not conditional on
the O_NONBLOCK setting.</p>
<p>The standard developers rejected a proposal to add <i>closefrom</i>() to the standard. Because the standard permits
implementations to use inherited file descriptors as a means of providing a conforming environment for the child process, it is not
possible to standardize an interface that closes arbitrary file descriptors above a certain value while still guaranteeing a
conforming environment.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_81_09" id="tag_17_81_09"></a>FUTURE DIRECTIONS</h4>
<blockquote>
<p>None.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_81_10" id="tag_17_81_10"></a>SEE ALSO</h4>
<blockquote>
<p><a href="../functions/dup.html#"><i>dup</i>()</a>, <a href="../functions/exec.html#tag_17_129"></a><a href=
"../functions/exec.html">exec</a>, <a href="../functions/exit.html#tag_17_130"><i>exit</i>()</a>, <a href=
"../functions/fclose.html#"><i>fclose</i>()</a>, <a href="../functions/fopen.html#"><i>fopen</i>()</a>, <a href=
"../functions/fork.html#"><i>fork</i>()</a>, <a href="../functions/open.html#"><i>open</i>()</a>, <a href=
"../functions/perror.html#"><i>perror</i>()</a>, <a href="../functions/unlink.html#tag_17_649"><i>unlink</i>()</a></p>
<p>XBD <a href="../basedefs/unistd.h.html"><i>&lt;unistd.h&gt;</i></a></p>
</blockquote>
<h4 class="mansect"><a name="tag_17_81_11" id="tag_17_81_11"></a>CHANGE HISTORY</h4>
<blockquote>
<p>First released in Issue 1. Derived from Issue 1 of the SVID.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_81_12" id="tag_17_81_12"></a>Issue 5</h4>
<blockquote>
<p>The DESCRIPTION is updated for alignment with the POSIX Realtime Extension.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_81_13" id="tag_17_81_13"></a>Issue 6</h4>
<blockquote>
<p>The DESCRIPTION related to a STREAMS-based file or pseudo-terminal is marked as part of the XSI STREAMS Option Group.</p>
<p>The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:</p>
<ul>
<li>
<p>The [EIO] error condition is added as an optional error.</p>
</li>
<li>
<p>The DESCRIPTION is updated to describe the state of the <i>fildes</i> file descriptor as unspecified if an I/O error occurs and
an [EIO] error condition is returned.</p>
</li>
</ul>
<p>Text referring to sockets is added to the DESCRIPTION.</p>
<p>The DESCRIPTION is updated for alignment with IEEE&nbsp;Std&nbsp;1003.1j-2000 by specifying that shared memory objects and
memory mapped files (and not typed memory objects) are the types of memory objects to which the paragraph on last closes
applies.</p>
<p>IEEE&nbsp;Std&nbsp;1003.1-2001/Cor&nbsp;1-2002, item XSH/TC1/D6/12 is applied, correcting the XSH shaded text relating to the
manager side of a pseudo-terminal. The reason for the change is that the behavior of pseudo-terminals and regular terminals should
be as much alike as possible in this case; the change achieves that and matches historical behavior.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_81_14" id="tag_17_81_14"></a>Issue 7</h4>
<blockquote>
<p>Functionality relating to the XSI STREAMS option is marked obsolescent.</p>
<p>Functionality relating to the Asynchronous Input and Output and Memory Mapped Files options is moved to the Base.</p>
<p>Austin Group Interpretation 1003.1-2001 #139 is applied, clarifying that the requirement for <i>close</i>() on a socket to block
for up to the current linger interval is not conditional on the O_NONBLOCK setting.</p>
<p>POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0059 [419], XSH/TC1-2008/0060 [149], and XSH/TC1-2008/0061 [149] are
applied.</p>
<p>POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0069 [555] is applied.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_81_15" id="tag_17_81_15"></a>Issue 8</h4>
<blockquote>
<p>Austin Group Defect 529 is applied, adding the <i>posix_close</i>() function and changing requirements for the <i>close</i>()
function relating to [EINTR].</p>
<p>Austin Group Defect 768 is applied, adding OFD-owned file locks.</p>
<p>Austin Group Defect 1330 is applied, removing obsolescent interfaces.</p>
<p>Austin Group Defect 1466 is applied, changing the terminology used for pseudo-terminal devices.</p>
<p>Austin Group Defect 1525 is applied, clarifying that a socket is not destroyed until all file descriptors associated with it
have been closed.</p>
</blockquote>
<div class="box"><em>End of informative text.</em></div>
<hr>
<p>&nbsp;</p>
<a href="#top"><span class="topOfPage">return to top of page</span></a><br>
<hr size="2" noshade>
<center><font size="2">UNIX® is a registered Trademark of The Open Group.<br>
POSIX™ is a Trademark of The IEEE.<br>
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved<br>
[ <a href="../mindex.html">Main Index</a> | <a href="../basedefs/contents.html">XBD</a> | <a href=
"../functions/contents.html">XSH</a> | <a href="../utilities/contents.html">XCU</a> | <a href="../xrat/contents.html">XRAT</a>
]</font></center>
<hr size="2" noshade>
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/clog.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/closedir.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>
<hr align="left" width="100%"></div>
</body>
</html>
