<!-- Copyright 2001-2024 IEEE and The Open Group, All Rights Reserved -->
<!DOCTYPE HTML>
<html lang="en">
<head>
<meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.8.0">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link type="text/css" rel="stylesheet" href="style.css"><!-- Generated by The Open Group rhtm tool v1.2.4 -->
<!-- Copyright (c) 2001-2024 The Open Group, All Rights Reserved -->
<title>fcntl</title>
</head>
<body bgcolor="white">
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/fclose.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/fdatasync.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>
<hr align="left" width="100%"></div>
<script language="JavaScript" src="../jscript/codes.js"></script><basefont size="3">
<center><font size="2">The Open Group Base Specifications Issue 8<br>
IEEE Std 1003.1-2024<br>
Copyright © 2001-2024 The IEEE and The Open Group</font></center>
<hr size="2" noshade>
<a name="top" id="top"></a> <a name="fcntl" id="fcntl"></a> <a name="tag_17_139" id="tag_17_139"></a><!-- fcntl -->
<h4 class="mansect"><a name="tag_17_139_01" id="tag_17_139_01"></a>NAME</h4>
<blockquote>fcntl — file control</blockquote>
<h4 class="mansect"><a name="tag_17_139_02" id="tag_17_139_02"></a>SYNOPSIS</h4>
<blockquote class="synopsis">
<p><code><tt>#include &lt;<a href="../basedefs/fcntl.h.html">fcntl.h</a>&gt;<br>
<br>
int fcntl(int</tt> <i>fildes</i><tt>, int</tt> <i>cmd</i><tt>, ...);<br></tt></code></p>
</blockquote>
<h4 class="mansect"><a name="tag_17_139_03" id="tag_17_139_03"></a>DESCRIPTION</h4>
<blockquote>
<p>The <i>fcntl</i>() function shall perform the operations described below on open files. The <i>fildes</i> argument is a file
descriptor.</p>
<p>The available values for <i>cmd</i> are defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a> and are as
follows:</p>
<dl compact>
<dd></dd>
<dt>F_DUPFD</dt>
<dd>Return a new file descriptor which shall be allocated as described in <a href="../functions/V2_chap02.html#tag_16_06"><i>2.6
File Descriptor Allocation</i></a>, except that it shall be the lowest numbered available file descriptor greater than or equal to
the third argument, <i>arg</i>, taken as an integer of type <b>int</b>. The new file descriptor shall refer to the same open file
description as the original file descriptor, and shall share any locks. The FD_CLOEXEC and FD_CLOFORK flags associated with the new
file descriptor shall be cleared.</dd>
<dt>F_DUPFD_CLOEXEC</dt>
<dd>
Like F_DUPFD, but the FD_CLOEXEC flag associated with the new file descriptor shall be set.</dd>
<dt>F_DUPFD_CLOFORK</dt>
<dd>
Like F_DUPFD, but the FD_CLOFORK flag associated with the new file descriptor shall be set.</dd>
<dt>F_GETFD</dt>
<dd>Get the file descriptor flags defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a> that are associated with
the file descriptor <i>fildes</i>. File descriptor flags are associated with a single file descriptor and do not affect other file
descriptors that refer to the same file.</dd>
<dt>F_SETFD</dt>
<dd>Set the file descriptor flags defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>, that are associated
with <i>fildes</i>, to the third argument, <i>arg</i>, taken as type <b>int</b>. If the FD_CLOEXEC flag in the third argument is
set, the file descriptor shall be closed upon successful execution of an <i><a href="../functions/exec.html">exec</a></i> family
function <sup>[<a href="javascript:open_code('SPN')">SPN</a>]</sup> <img src="../images/opt-start.gif" alt="[Option Start]" border=
"0"> and in the new process image created by <a href="../functions/posix_spawn.html"><i>posix_spawn</i>()</a> or <a href=
"../functions/posix_spawnp.html"><i>posix_spawnp</i>()</a>; <img src="../images/opt-end.gif" alt="[Option End]" border="0">
otherwise, the file descriptor shall remain open. If the FD_CLOFORK flag in the third argument is set, the file descriptor shall
not be inherited by any child process created from a process that has the file descriptor open; otherwise, the file descriptor
shall be inherited.</dd>
<dt>F_GETFL</dt>
<dd>Get the file status flags and file access modes, defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>, for
the file description associated with <i>fildes</i>. The file access modes can be extracted from the return value using the mask
O_ACCMODE, which is defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>. File status flags and file access
modes are associated with the file description and do not affect other file descriptors that refer to the same file with different
open file descriptions. The flags returned may include non-standard file status flags which the application did not set, provided
that these additional flags do not alter the behavior of a conforming application.</dd>
<dt>F_SETFL</dt>
<dd>Set the file status flags, defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>, for the file description
associated with <i>fildes</i> from the corresponding bits in the third argument, <i>arg</i>, taken as type <b>int</b>. Bits
corresponding to the file access mode and the file creation flags, as defined in <a href=
"../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>, that are set in <i>arg</i> shall be ignored. If any bits in <i>arg</i> other
than those mentioned here are changed by the application, the result is unspecified. If <i>fildes</i> does not support non-blocking
operations, it is unspecified whether the O_NONBLOCK flag will be ignored.</dd>
<dt>F_GETOWN</dt>
<dd>If <i>fildes</i> refers to a socket, get the process ID or process group ID specified to receive SIGURG signals when
out-of-band data is available. Positive values shall indicate a process ID; negative values, other than -1, shall indicate a
process group ID; the value zero shall indicate that no SIGURG signals are to be sent. If <i>fildes</i> does not refer to a socket,
the results are unspecified.</dd>
<dt>F_SETOWN</dt>
<dd>If <i>fildes</i> refers to a socket, atomically set the process ID or process group ID specified to receive SIGURG signals when
out-of-band data is available, using the value of the third argument, <i>arg</i>, taken as type <b>int</b>. Positive values shall
indicate a process ID; negative values, other than -1, shall indicate a process group ID; the value zero shall indicate that no
SIGURG signals are to be sent. If <i>fildes</i> does not refer to a socket, the results are unspecified.</dd>
<dt>F_GETOWN_EX</dt>
<dd>If <i>fildes</i> refers to a socket, get the process ID or process group ID specified to receive SIGURG signals when
out-of-band data is available, by setting the <i>type</i> and <i>pid</i> members of the <b>f_owner_ex</b> structure pointed to by
the third argument, <i>arg</i>. The value of <i>type</i> shall be F_OWNER_PID or F_OWNER_PGRP to indicate that <i>pid</i> contains
a process ID or a process group ID, respectively. The value of <i>pid</i> shall be zero if no SIGURG signals are to be sent. If
<i>fildes</i> does not refer to a socket, the results are unspecified.</dd>
<dt>F_SETOWN_EX</dt>
<dd>If <i>fildes</i> refers to a socket, set the process ID or process group ID specified to receive SIGURG signals when
out-of-band data is available, using the value of the third argument, <i>arg</i>, taken as type pointer to <b>struct
f_owner_ex</b>. The <i>type</i> and <i>pid</i> members of this structure shall be used as follows:
<ul>
<li>
<p>A <i>pid</i> value of zero shall indicate that no SIGURG signals are to be sent.</p>
</li>
<li>
<p>A <i>type</i> value of F_OWNER_PID and a positive <i>pid</i> value shall indicate that SIGURG signals are to be sent to the
process ID specified in <i>pid</i>.</p>
</li>
<li>
<p>A <i>type</i> value of F_OWNER_PGRP and a positive <i>pid</i> value shall indicate that SIGURG signals are to be sent to the
process group ID specified in <i>pid</i>.</p>
</li>
</ul>
<p>If <i>fildes</i> does not refer to a socket, the results are unspecified.</p>
</dd>
</dl>
<p>For F_SETOWN and F_SETOWN_EX, each time a SIGURG signal is sent to the specified process or process group, permission checks
equivalent to those performed by <a href="../functions/kill.html"><i>kill</i>()</a> shall be performed, as if <a href=
"../functions/kill.html"><i>kill</i>()</a> were called by a process with the same real user ID, effective user ID, and privileges
that the process calling <i>fcntl</i>() has at the time of the call; if the <a href="../functions/kill.html"><i>kill</i>()</a> call
would fail, no signal shall be sent. These permission checks may also be performed by the <i>fcntl</i>() call. If the process
specified by <i>arg</i> later terminates, or the process group specified by <i>arg</i> later becomes empty, while still being
specified to receive SIGURG signals when out-of-band data is available from <i>fildes</i>, then no signals shall be sent to any
subsequently created process that has the same process ID or process group ID, regardless of permission; it is unspecified whether
this is achieved by the equivalent of a <i>fcntl</i>(<i>fildes</i>, F_SETOWN, 0) call at the time the process terminates or is
waited for or the process group becomes empty, or by other means.</p>
<p>The following values for <i>cmd</i> are available for advisory record locking. Record locking shall be supported for regular
files, and may be supported for other files.</p>
<dl compact>
<dd></dd>
<dt>F_GETLK</dt>
<dd>Get any lock which blocks the process-owned file lock description pointed to by the third argument, <i>arg</i>, taken as a
pointer to type <b>struct flock</b>, defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>. The information
retrieved shall overwrite the information passed to <i>fcntl</i>() in the structure <b>flock</b>. If no lock is found that would
prevent this lock from being created, then the structure shall be left unchanged except for the lock type in <i>l_type</i> which
shall be set to F_UNLCK.</dd>
<dt>F_SETLK</dt>
<dd>Set or clear a process-owned file lock according to the lock description pointed to by the third argument, <i>arg</i>, taken as
a pointer to type <b>struct flock</b>, defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>. F_SETLK can
establish shared (or read) locks (F_RDLCK) or exclusive (or write) locks (F_WRLCK), as well as remove either type of lock
(F_UNLCK). F_RDLCK, F_WRLCK, and F_UNLCK are defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>. If a shared
or exclusive lock cannot be set, <i>fcntl</i>() shall return immediately with a return value of -1.</dd>
<dt>F_SETLKW</dt>
<dd>This command shall be equivalent to F_SETLK except that if a shared or exclusive lock is blocked by other locks, the thread
shall wait until the request can be satisfied. If a signal that is to be caught is received while <i>fcntl</i>() is waiting for a
region, <i>fcntl</i>() shall be interrupted. Upon return from the signal handler, <i>fcntl</i>() shall return -1 with <i>errno</i>
set to [EINTR], and the lock operation shall not be done.</dd>
<dt>F_OFD_GETLK</dt>
<dd>Get any lock which blocks the OFD-owned file lock description pointed to by the third argument, <i>arg</i>, taken as a pointer
to type <b>struct flock</b>, defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>; the application shall ensure
that the <i>l_pid</i> member of the structure pointed to by <i>arg</i> is set to 0 on input. The information retrieved shall
overwrite the information passed to <i>fcntl</i>() in the structure <b>flock</b>. If no lock is found that would prevent this lock
from being created, then the structure shall be left unchanged except for the lock type in <i>l_type</i> which shall be set to
F_UNLCK.</dd>
<dt>F_OFD_SETLK</dt>
<dd>Set or clear an OFD-owned file lock according to the lock description pointed to by the third argument, <i>arg</i>, taken as a
pointer to type <b>struct flock</b>, defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>; the application
shall ensure that the <i>l_pid</i> member of the structure pointed to by <i>arg</i> is set to 0 on input. F_OFD_SETLK can establish
shared (or read) locks (F_RDLCK) or exclusive (or write) locks (F_WRLCK), as well as remove either type of lock (F_UNLCK). F_RDLCK,
F_WRLCK, and F_UNLCK are defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>. If a shared or exclusive lock
cannot be set, <i>fcntl</i>() shall return immediately with a return value of -1.</dd>
<dt>F_OFD_SETLKW</dt>
<dd>This command shall be equivalent to F_OFD_SETLK except that if a shared or exclusive lock is blocked by other locks, the thread
shall wait until the request can be satisfied. If a signal that is to be caught is received while <i>fcntl</i>() is waiting for a
region, <i>fcntl</i>() shall be interrupted. Upon return from the signal handler, <i>fcntl</i>() shall return -1 with <i>errno</i>
set to [EINTR], and the lock operation shall not be done.</dd>
</dl>
<p>Additional implementation-defined values for <i>cmd</i> may be defined in <a href=
"../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>. Their names shall start with F_.</p>
<p>When a shared lock is set on a segment of a file, other processes can set shared process-owned locks, and other open file
descriptions can be used to set shared OFD-owned locks, on that segment or a portion of it. A shared process-owned lock shall
prevent any other process from setting an exclusive process-owned lock, and shall prevent any exclusive OFD-owned lock from being
set, on any portion of the protected area. A shared OFD-owned lock shall prevent any other open file description from being used to
set an exclusive OFD-owned lock, and shall prevent any exclusive process-owned lock from being set, on any portion of the protected
area. A request for a shared lock shall fail if the file descriptor is not open for reading.</p>
<p>An exclusive process-owned lock shall prevent any other process from setting a shared or exclusive process-owned lock, and shall
prevent any shared or exclusive OFD-owned lock from being set, on any portion of the protected area. An exclusive OFD-owned lock
shall prevent any other open file description from being used to set a shared or exclusive OFD-owned lock, and shall prevent any
shared or exclusive process-owned lock from being set, on any portion of the protected area. A request for an exclusive lock shall
fail if the file descriptor is not open for writing.</p>
<p>The structure <b>flock</b> describes the type (<i>l_type</i>), starting offset (<i>l_whence</i>), relative offset
(<i>l_start</i>), size (<i>l_len</i>), and process ID (<i>l_pid</i>) of the segment of the file to be affected.</p>
<p>The value of <i>l_whence</i> is SEEK_SET, SEEK_CUR, or SEEK_END, to indicate that the relative offset <i>l_start</i> bytes shall
be measured from the start of the file, current position, or end of the file, respectively. The value of <i>l_len</i> is the number
of consecutive bytes to be locked. The value of <i>l_len</i> may be negative (where the definition of <b>off_t</b> permits negative
values of <i>l_len</i>). On input, the <i>l_pid</i> field shall be ignored for F_GETLK, F_SETLK and F_SETLKW; the application shall
ensure that it is set to zero for F_OFD_GETLK, F_OFD_SETLK and F_OFD_SETLKW. It is set by F_GETLK and F_OFD_GETLK when identifying
a blocking lock. After a successful F_GETLK or F_OFD_GETLK request, when a blocking lock is found, the values returned in the
<b>flock</b> structure shall be as follows:</p>
<dl compact>
<dd></dd>
<dt><i>l_type</i></dt>
<dd>Type of blocking lock found.</dd>
<dt><i>l_whence</i></dt>
<dd>SEEK_SET.</dd>
<dt><i>l_start</i></dt>
<dd>Start of the blocking lock.</dd>
<dt><i>l_len</i></dt>
<dd>Length of the blocking lock.</dd>
<dt><i>l_pid</i></dt>
<dd>Process ID of the process that holds the blocking lock if the blocking lock is a process-owned file lock, or (<b>pid_t</b>)-1
if the blocking lock is an OFD-owned file lock.</dd>
</dl>
<p>If the command is F_SETLKW or F_OFD_SETLKW and the thread needs to wait for a blocking lock to be released, then the range of
bytes to be locked shall be determined before the <i>fcntl</i>() function blocks. If the file size or file descriptor seek offset
change while <i>fcntl</i>() is blocked, this shall not affect the range of bytes locked.</p>
<p>If <i>l_len</i> is positive, the area affected shall start at <i>l_start</i> and end at <i>l_start</i>+<i>l_len</i>-1. If
<i>l_len</i> is negative, the area affected shall start at <i>l_start</i>+<i>l_len</i> and end at <i>l_start</i>-1. Locks may start
and extend beyond the current end of a file, but shall not extend before the beginning of the file. A lock shall be set to extend
to the largest possible value of the file offset for that file by setting <i>l_len</i> to 0. If such a lock also has <i>l_start</i>
set to 0 and <i>l_whence</i> is set to SEEK_SET, the whole file shall be locked.</p>
<p>Each byte in the file can be locked either with one or more shared locks (F_RDLCK) or with one exclusive lock (F_WRLCK).</p>
<p>Before a successful return from an F_SETLK or an F_SETLKW request when the calling process has previously existing process-owned
locks on bytes in the region specified by the request, the previous shared or exclusive lock for each byte in the specified region
shall be replaced by the new shared or exclusive lock. An F_SETLK or an F_SETLKW request (respectively) shall fail or block when
another process has existing process-owned locks, or any open file description (including the one associated with <i>fildes</i>)
has existing OFD-owned locks, on bytes in the specified region and any of those locks conflicts with the requested lock.</p>
<p>Before a successful return from an F_OFD_SETLK or an F_OFD_SETLKW request when the open file description associated with fildes
has previously existing OFD-owned locks on bytes in the region specified by the request, the previous shared or exclusive lock for
each byte in the specified region shall be replaced by the new shared or exclusive lock. An F_OFD_SETLK or an F_OFD_SETLKW request
(respectively) shall fail or block when another open file description has existing OFD-owned locks, or any process (including the
calling process) has existing process-owned locks, on bytes in the specified region and any of those locks conflicts with the
requested lock.</p>
<p>All process-owned locks associated with a file for a given process shall be removed when any file descriptor for that file is
closed by that process (even if via a different open file description) or the process holding that file descriptor terminates.
Process-owned locks shall not be inherited by a child process.</p>
<p>All OFD-owned locks associated with a given open file description shall be removed when all file descriptors associated with
that open file description have been closed (either directly or as a side-effect of, for example, process termination or
FD_CLOEXEC). OFD-owned locks shall be shared across all file descriptors that are associated with the owning open file description,
regardless of which process holds the file descriptor.</p>
<p>A potential for deadlock occurs if a process or thread controlling a locked region is put to sleep by attempting to lock a
region that has an existing conflicting lock. If the system detects that sleeping until a locked region is unlocked would cause a
deadlock, <i>fcntl</i>() shall fail with an [EDEADLK] error. Deadlock detection may differ between process-owned locks and
OFD-owned locks.</p>
<p><sup>[<a href="javascript:open_code('XSI')">XSI</a>]</sup> <img src="../images/opt-start.gif" alt="[Option Start]" border="0">
The interaction between <i>fcntl</i>() and <a href="../functions/lockf.html"><i>lockf</i>()</a> locks is unspecified. <img src=
"../images/opt-end.gif" alt="[Option End]" border="0"></p>
<p>An unlock (F_UNLCK) request in which <i>l_len</i> is non-zero and the offset of the last byte of the requested segment is the
maximum value for an object of type <b>off_t</b>, when the process (for F_SETLK and F_SETLKW) or open file description (for
F_OFD_SETLK and F_OFD_SETLKW) has an existing lock in which <i>l_len</i> is 0 and which includes the last byte of the requested
segment, shall be treated as a request to unlock from the start of the requested segment with an <i>l_len</i> equal to 0.
Otherwise, an unlock (F_UNLCK) request shall attempt to unlock only the requested segment.</p>
<p><sup>[<a href="javascript:open_code('SHM')">SHM</a>]</sup> <img src="../images/opt-start.gif" alt="[Option Start]" border="0">
When the file descriptor <i>fildes</i> refers to a shared memory object, the behavior of <i>fcntl</i>() shall be the same as for a
regular file except the effect of the following values for the argument <i>cmd</i> is unspecified: F_SETFL, F_GETLK, F_SETLK,
F_SETLKW, F_OFD_GETLK, F_OFD_SETLK, and F_OFD_SETLKW. <img src="../images/opt-end.gif" alt="[Option End]" border="0"></p>
<p><sup>[<a href="javascript:open_code('TYM')">TYM</a>]</sup> <img src="../images/opt-start.gif" alt="[Option Start]" border="0">
If <i>fildes</i> refers to a typed memory object, the result of the <i>fcntl</i>() function is unspecified. <img src=
"../images/opt-end.gif" alt="[Option End]" border="0"></p>
</blockquote>
<h4 class="mansect"><a name="tag_17_139_04" id="tag_17_139_04"></a>RETURN VALUE</h4>
<blockquote>
<p>Upon successful completion, the value returned shall depend on <i>cmd</i> as follows:</p>
<dl compact>
<dd></dd>
<dt>F_DUPFD</dt>
<dd>A new file descriptor.</dd>
<dt>F_DUPFD_CLOEXEC</dt>
<dd>
A new file descriptor.</dd>
<dt>F_DUPFD_CLOFORK</dt>
<dd>
A new file descriptor.</dd>
<dt>F_GETFD</dt>
<dd>Value of flags defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>. The return value shall not be
negative.</dd>
<dt>F_SETFD</dt>
<dd>Value other than -1.</dd>
<dt>F_GETFL</dt>
<dd>Value of file status flags and access modes. The return value shall not be negative.</dd>
<dt>F_SETFL</dt>
<dd>Value other than -1.</dd>
<dt>F_GETLK</dt>
<dd>Value other than -1.</dd>
<dt>F_SETLK</dt>
<dd>Value other than -1.</dd>
<dt>F_SETLKW</dt>
<dd>Value other than -1.</dd>
<dt>F_OFD_GETLK</dt>
<dd>Value other than -1.</dd>
<dt>F_OFD_SETLK</dt>
<dd>Value other than -1.</dd>
<dt>F_OFD_SETLKW</dt>
<dd>
Value other than -1.</dd>
<dt>F_GETOWN</dt>
<dd>Value of the socket owner process or process group; this shall not be -1.</dd>
<dt>F_SETOWN</dt>
<dd>Value other than -1.</dd>
<dt>F_GETOWN_EX</dt>
<dd>Value other than -1.</dd>
<dt>F_SETOWN_EX</dt>
<dd>Value other than -1.</dd>
</dl>
<p>Otherwise, -1 shall be returned and <i>errno</i> set to indicate the error.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_139_05" id="tag_17_139_05"></a>ERRORS</h4>
<blockquote>
<p>The <i>fcntl</i>() function shall fail if:</p>
<dl compact>
<dd></dd>
<dt>[EACCES] or [EAGAIN]</dt>
<dd>
The <i>cmd</i> argument is F_SETLK, the type of lock (<i>l_type</i>) is a shared (F_RDLCK) or exclusive (F_WRLCK) lock, and the
requested lock cannot be set because it is blocked by an existing lock on the file.</dd>
<dt>[EAGAIN]</dt>
<dd>The <i>cmd</i> argument is F_OFD_SETLK, the type of lock (<i>l_type</i>) is a shared (F_RDLCK) or exclusive (F_WRLCK) lock, and
the requested lock cannot be set because it is blocked by an existing lock on the file.</dd>
<dt>[EBADF]</dt>
<dd>The <i>fildes</i> argument is not a valid open file descriptor; or the argument <i>cmd</i> is F_SETLK, F_SETLKW, F_OFD_SETLK,
or F_OFD_SETLKW, the type of lock, <i>l_type</i>, is a shared lock (F_RDLCK), and <i>fildes</i> is not a valid file descriptor open
for reading, or the type of lock, <i>l_type</i>, is an exclusive lock (F_WRLCK), and <i>fildes</i> is not a valid file descriptor
open for writing.</dd>
<dt>[EINTR]</dt>
<dd>The <i>cmd</i> argument is F_SETLKW or F_OFD_SETLKW and the function was interrupted by a signal.</dd>
<dt>[EINVAL]</dt>
<dd>The <i>cmd</i> argument is invalid; or the <i>cmd</i> argument is F_DUPFD, F_DUPFD_CLOEXEC, or F_DUPFD_CLOFORK and <i>arg</i>
is negative or is greater than or equal to {OPEN_MAX}; or the <i>cmd</i> argument is F_SETOWN_EX and the <i>type</i> member of the
<b>f_owner_ex</b> structure pointed to by <i>arg</i> is invalid, or the <i>pid</i> member is negative and the <i>type</i> member is
F_OWNER_PID or F_OWNER_PGRP; or the <i>cmd</i> argument is F_GETLK, F_SETLK, F_SETLKW, F_OFD_GETLK, F_OFD_SETLK, or F_OFD_SETLKW
and the data pointed to by <i>arg</i> is not valid, or <i>fildes</i> refers to a file that does not support locking.</dd>
<dt>[EMFILE]</dt>
<dd>The argument <i>cmd</i> is F_DUPFD, F_DUPFD_CLOEXEC, or F_DUPFD_CLOFORK and all file descriptors available to the process are
currently open, or no file descriptors greater than or equal to <i>arg</i> are available.</dd>
<dt>[ENOLCK]</dt>
<dd>The argument <i>cmd</i> is F_SETLK, F_SETLKW, F_OFD_SETLK, or F_OFD_SETLKW and satisfying the lock or unlock request would
result in the number of locked regions in the system exceeding a system-imposed limit.</dd>
<dt>[EOVERFLOW]</dt>
<dd>One of the values to be returned cannot be represented correctly.</dd>
<dt>[EOVERFLOW]</dt>
<dd>The <i>cmd</i> argument is F_GETLK, F_SETLK, F_SETLKW, F_OFD_GETLK, F_OFD_SETLK, or F_OFD_SETLKW and the smallest or, if
<i>l_len</i> is non-zero, the largest offset of any byte in the requested segment cannot be represented correctly in an object of
type <b>off_t</b>.</dd>
<dt>[ESRCH]</dt>
<dd>The <i>cmd</i> argument is F_SETOWN or F_SETOWN_EX and no process or process group can be found corresponding to that specified
by <i>arg</i>.</dd>
</dl>
<br>
<p>The <i>fcntl</i>() function may fail if:</p>
<dl compact>
<dd></dd>
<dt>[EDEADLK]</dt>
<dd>The <i>cmd</i> argument is F_SETLKW or F_OFD_SETLKW, the type of lock (<i>l_type</i>) is a shared (F_RDLCK) or exclusive
(F_WRLCK) lock, the requested lock is blocked by an existing lock on the file, and the system determines that waiting for that lock
to be released would cause a deadlock.</dd>
<dt>[EINVAL]</dt>
<dd>The <i>cmd</i> argument is F_SETOWN and the value of <i>arg</i> is positive and is not valid as a process ID or the value of
<i>arg</i> is negative and its absolute value is not valid as a process group ID; or the <i>cmd</i> argument is F_SETOWN_EX, the
value of the <i>type</i> member of the <b>f_owner_ex</b> structure pointed to by <i>arg</i> is F_OWNER_PID, and the value of the
<i>pid</i> member is not valid as a process ID; or the <i>cmd</i> argument is F_SETOWN_EX, the value of the <i>type</i> member of
the <b>f_owner_ex</b> structure pointed to by <i>arg</i> is F_OWNER_PGRP, and the value of the <i>pid</i> member is not valid as a
process group ID.</dd>
<dt>[EPERM]</dt>
<dd>The <i>cmd</i> argument is F_SETOWN or F_SETOWN_EX and the calling process does not have permission to send a SIGURG signal to
any process specified by <i>arg</i>.</dd>
</dl>
</blockquote>
<hr>
<div class="box"><em>The following sections are informative.</em></div>
<h4 class="mansect"><a name="tag_17_139_06" id="tag_17_139_06"></a>EXAMPLES</h4>
<blockquote>
<h5><a name="tag_17_139_06_01" id="tag_17_139_06_01"></a>Locking and Unlocking a File</h5>
<p>The following example demonstrates how to place a lock on bytes 100 to 109 of a file and then later remove it. F_SETLK is used
to perform a non-blocking lock request so that the process does not have to wait if an incompatible lock is held by another
process; instead the process can take some other action.</p>
<pre>
<tt>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
<br>
int
main(int argc, char *argv[])
{
    int fd;
    struct flock fl;
<br>
    fd = open("testfile", O_RDWR);
    if (fd == -1)
        /* Handle error */;
<br>
    /* Make a non-blocking request to place a write lock
       on bytes 100-109 of testfile */
<br>
    fl.l_type = F_WRLCK;
    fl.l_whence = SEEK_SET;
    fl.l_start = 100;
    fl.l_len = 10;
<br>
    if (fcntl(fd, F_SETLK, &amp;fl) == -1) {
        if (errno == EACCES || errno == EAGAIN) {
            printf("Already locked by another process\n");
<br>
            /* We cannot get the lock at the moment */
<br>
        } else {
            /* Handle unexpected error */;
        }
    } else { /* Lock was granted... */
<br>
        /* Perform I/O on bytes 100 to 109 of file */
<br>
        /* Unlock the locked bytes */
<br>
        fl.l_type = F_UNLCK;
        fl.l_whence = SEEK_SET;
        fl.l_start = 100;
        fl.l_len = 10;
        if (fcntl(fd, F_SETLK, &amp;fl) == -1)
            /* Handle error */;
    }
    exit(EXIT_SUCCESS);
} /* main */
</tt></pre>
<h5><a name="tag_17_139_06_02" id="tag_17_139_06_02"></a>Setting the Close-on-Exec Flag</h5>
<p>The following example demonstrates how to set the close-on-exec flag for the file descriptor <i>fd</i>.</p>
<pre>
<tt>#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
...
    int flags;
<br>
    flags = fcntl(fd, F_GETFD);
    if (flags == -1)
        /* Handle error */;
    flags |= FD_CLOEXEC;
    if (fcntl(fd, F_SETFD, flags) == -1)
        /* Handle error */;"
</tt></pre></blockquote>
<h4 class="mansect"><a name="tag_17_139_07" id="tag_17_139_07"></a>APPLICATION USAGE</h4>
<blockquote>
<p>The <i>arg</i> values to F_GETFD, F_SETFD, F_GETFL, and F_SETFL all represent flag values to allow for future growth.
Applications using these functions should do a read-modify-write operation on them, rather than assuming that only the values
defined by this volume of POSIX.1-2024 are valid. It is a common error to forget this, particularly in the case of F_SETFD. Some
implementations set additional file status flags to advise the application of default behavior, even though the application did not
request these flags.</p>
<p>In order to set both FD_CLOEXEC and FD_CLOFORK when duplicating a file descriptor, applications should use F_DUPFD_CLOFORK to
obtain the new file descriptor with FD_CLOFORK already set, and then use F_SETFD to set the FD_CLOEXEC flag on the new descriptor.
(The alternative of first using F_DUPFD_CLOEXEC and then setting FD_CLOFORK with F_SETFD has a timing window where another thread
could create a child process which inherits the new descriptor because FD_CLOFORK has not yet been set.)</p>
<p>The FD_CLOFORK flag takes effect for all child processes, not just those created using <a href=
"../functions/fork.html"><i>fork</i>()</a> or <a href="../functions/_Fork.html"><i>_Fork</i>()</a>.</p>
<p>On implementations where process IDs can be greater than {INT_MAX}, F_SETOWN cannot be used with process IDs greater than
{INT_MAX} or process group IDs greater than {INT_MAX}+1 because the value is passed to <i>fcntl</i>() in an argument of type
<b>int</b>. In this situation, F_SETOWN_EX should be used instead.</p>
<p>Similarly, if a process ID greater than {INT_MAX} or a process group ID greater than {INT_MAX}+1 has been set to receive SIGURG
signals (using F_SETOWN_EX), F_GETOWN cannot be used to obtain the value because <i>fcntl</i>() returns the value as type
<b>int</b> and will thus give an [EOVERFLOW] error for such values. F_GETOWN_EX should be used instead.</p>
<p>Note that the convention of negating a process group ID is only used with F_SETOWN and F_GETOWN; the <i>pid</i> member of the
<b>f_owner_ex</b> structure used with F_SETOWN_EX and F_GETOWN_EX is not negated when it specifies a process group ID.</p>
<p>On systems which do not perform permission checks at the time of an <i>fcntl</i>() call with F_SETOWN or F_SETOWN_EX, if the
permission checks performed at the time the signal is sent disallow sending the signal to any process, the process that called
<i>fcntl</i>() has no way of discovering that this has happened. A call to <a href="../functions/kill.html"><i>kill</i>()</a> with
signal 0 can be used as a prior check of permissions, although this is no guarantee that permission will be granted at the time a
signal is sent, since the target process(es) could change user IDs or privileges in the meantime.</p>
<p>Record-locking should not be used in combination with buffered standard I/O streams (see <a href=
"../functions/V2_chap02.html#tag_16_05"><i>2.5 Standard I/O Streams</i></a>). Instead, non-buffered I/O should be used. Unexpected
results may occur in processes that do buffering in the user address space. The process may later read/write data which is/was
locked. Functions that operate on standard I/O streams are the most common source of such buffering.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_139_08" id="tag_17_139_08"></a>RATIONALE</h4>
<blockquote>
<p>The ellipsis in the SYNOPSIS is the syntax specified by the ISO&nbsp;C standard for a variable number of arguments. It is used
because System V uses pointers for the implementation of file locking functions.</p>
<p>This volume of POSIX.1-2024 permits concurrent read and write access to file data using the <i>fcntl</i>() function; this is a
change from the 1984 /usr/group standard and early proposals. Without concurrency controls, this feature may not be fully utilized
without occasional loss of data.</p>
<p>Data losses occur in several ways. One case occurs when several processes try to update the same record, without sequencing
controls; several updates may occur in parallel and the last writer &quot;wins&quot;. Another case is a bit-tree or other internal
list-based database that is undergoing reorganization. Without exclusive use to the tree segment by the updating process, other
reading processes chance getting lost in the database when the index blocks are split, condensed, inserted, or deleted. While
<i>fcntl</i>() is useful for many applications, it is not intended to be overly general and does not handle the bit-tree example
well.</p>
<p>This facility is only required for regular files because it is not appropriate for many devices such as terminals and network
connections.</p>
<p>Since <i>fcntl</i>() works with &quot;any file descriptor associated with that file, however it is obtained&quot;, the file descriptor
may have been inherited through a <a href="../functions/fork.html"><i>fork</i>()</a> or <i><a href=
"../functions/exec.html">exec</a></i> operation and thus may affect a file that another process also has open.</p>
<p>The use of the open file description to identify what to lock requires extra calls and presents problems if several processes
are sharing an open file description, but there are too many implementations of the existing mechanism for this volume of
POSIX.1-2024 to use different specifications.</p>
<p>Another consequence of this model is that closing any file descriptor for a given file (whether or not it is the same open file
description that created the lock) causes the locks on that file to be relinquished for that process. Equivalently, any close for
any file/process pair relinquishes the locks owned on that file for that process. But note that while an open file description may
be shared through <a href="../functions/fork.html"><i>fork</i>()</a>, locks are not inherited through <a href=
"../functions/fork.html"><i>fork</i>()</a>. Yet locks may be inherited through one of the <i><a href=
"../functions/exec.html">exec</a></i> functions.</p>
<p>The identification of a machine in a network environment is outside the scope of this volume of POSIX.1-2024. Thus, an
<i>l_sysid</i> member, such as found in System V, is not included in the locking structure.</p>
<p>Changing of lock types can result in a previously locked region being split into smaller regions.</p>
<p>Mandatory locking was a major feature of the 1984 /usr/group standard.</p>
<p>For advisory file record locking to be effective, all processes that have access to a file must cooperate and use the advisory
mechanism before doing I/O on the file. Enforcement-mode record locking is important when it cannot be assumed that all processes
are cooperating. For example, if one user uses an editor to update a file at the same time that a second user executes another
process that updates the same file and if only one of the two processes is using advisory locking, the processes are not
cooperating. Enforcement-mode record locking would protect against accidental collisions.</p>
<p>Secondly, advisory record locking requires a process using locking to bracket each I/O operation with lock (or test) and unlock
operations. With enforcement-mode file and record locking, a process can lock the file once and unlock when all I/O operations have
been completed. Enforcement-mode record locking provides a base that can be enhanced; for example, with sharable locks. That is,
the mechanism could be enhanced to allow a process to lock a file so other processes could read it, but none of them could write
it.</p>
<p>Mandatory locks were omitted for several reasons:</p>
<ol>
<li>
<p>Mandatory lock setting was done by multiplexing the set-group-ID bit in most implementations; this was confusing, at best.</p>
</li>
<li>
<p>The relationship to file truncation as supported in 4.2 BSD was not well specified.</p>
</li>
<li>
<p>Any publicly readable file could be locked by anyone. Many historical implementations keep the password database in a publicly
readable file. A malicious user could thus prohibit logins. Another possibility would be to hold open a long-distance telephone
line.</p>
</li>
<li>
<p>Some demand-paged historical implementations offer memory mapped files, and enforcement cannot be done on that type of file.</p>
</li>
</ol>
<p>Since sleeping on a region is interrupted with any signal, <a href="../functions/alarm.html"><i>alarm</i>()</a> may be used to
provide a timeout facility in applications requiring it. This is useful in deadlock detection. Since implementation of full
deadlock detection is not always feasible, the [EDEADLK] error was made optional.</p>
<p>The F_SETOWN_EX and F_GETOWN_EX values for <i>cmd</i> and the associated <b>f_owner_ex</b> structure were adopted from the GNU C
library. In addition to the values F_OWNER_PID and F_OWNER_PGRP for the <i>type</i> member, this also has F_OWNER_TID to specify
that the <i>pid</i> member contains a thread ID. However, this relies on thread IDs being representable in a <b>pid_t</b> and so
was not included in POSIX.1-2024. The aim of adding F_SETOWN_EX and F_GETOWN_EX was to address the inability of F_SETOWN and
F_GETOWN to handle process IDs greater than {INT_MAX} and process group IDs greater than {INT_MAX}+1, and this need is satisfied
without including F_OWNER_TID.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_139_09" id="tag_17_139_09"></a>FUTURE DIRECTIONS</h4>
<blockquote>
<p>None.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_139_10" id="tag_17_139_10"></a>SEE ALSO</h4>
<blockquote>
<p><a href="../functions/alarm.html#"><i>alarm</i>()</a>, <a href="../functions/close.html#"><i>close</i>()</a>, <a href=
"../functions/exec.html#tag_17_129"></a><a href="../functions/exec.html">exec</a>, <a href=
"../functions/kill.html#tag_17_296"><i>kill</i>()</a>, <a href="../functions/open.html#"><i>open</i>()</a>, <a href=
"../functions/sigaction.html#"><i>sigaction</i>()</a></p>
<p>XBD <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>, <a href=
"../basedefs/signal.h.html"><i>&lt;signal.h&gt;</i></a></p>
</blockquote>
<h4 class="mansect"><a name="tag_17_139_11" id="tag_17_139_11"></a>CHANGE HISTORY</h4>
<blockquote>
<p>First released in Issue 1. Derived from Issue 1 of the SVID.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_139_12" id="tag_17_139_12"></a>Issue 5</h4>
<blockquote>
<p>The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.</p>
<p>Large File Summit extensions are added.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_139_13" id="tag_17_139_13"></a>Issue 6</h4>
<blockquote>
<p>In the SYNOPSIS, the optional include of the <a href="../basedefs/sys_types.h.html"><i>&lt;sys/types.h&gt;</i></a> header is
removed.</p>
<p>The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:</p>
<ul>
<li>
<p>The requirement to include <a href="../basedefs/sys_types.h.html"><i>&lt;sys/types.h&gt;</i></a> has been removed. Although
<a href="../basedefs/sys_types.h.html"><i>&lt;sys/types.h&gt;</i></a> was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.</p>
</li>
<li>
<p>In the DESCRIPTION, sentences describing behavior when <i>l_len</i> is negative are now mandated, and the description of unlock
(F_UNLOCK) when <i>l_len</i> is non-negative is mandated.</p>
</li>
<li>
<p>In the ERRORS section, the [EINVAL] error condition has the case mandated when the <i>cmd</i> is invalid, and two [EOVERFLOW]
error conditions are added.</p>
</li>
</ul>
<p>The F_GETOWN and F_SETOWN values are added for sockets.</p>
<p>The following changes were made to align with the IEEE&nbsp;P1003.1a draft standard:</p>
<ul>
<li>
<p>Clarification is added that the extent of the bytes locked is determined prior to the blocking action.</p>
</li>
</ul>
<p>The DESCRIPTION is updated for alignment with IEEE&nbsp;Std&nbsp;1003.1j-2000 by specifying that <i>fcntl</i>() results are
unspecified for typed memory objects.</p>
<p>The normative text is updated to avoid use of the term &quot;must&quot; for application requirements.</p>
<p>IEEE&nbsp;Std&nbsp;1003.1-2001/Cor&nbsp;2-2004, item XSH/TC2/D6/29 is applied, adding the example to the EXAMPLES section.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_139_14" id="tag_17_139_14"></a>Issue 7</h4>
<blockquote>
<p>Austin Group Interpretation 1003.1-2001 #150 is applied, clarifying the file status flags returned when <i>cmd</i> is
F_GETFL.</p>
<p>Austin Group Interpretation 1003.1-2001 #171 is applied, adding support to set the FD_CLOEXEC flag atomically at <a href=
"../functions/open.html"><i>open</i>()</a>, and adding the F_DUPFD_CLOEXEC flag.</p>
<p>The optional <a href="../basedefs/unistd.h.html"><i>&lt;unistd.h&gt;</i></a> header is removed from this function, since
<a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a> now defines SEEK_SET, SEEK_CUR, and SEEK_END as part of the Base.</p>
<p>POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0116 [141] is applied.</p>
<p>POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0105 [835], XSH/TC2-2008/0106 [677], XSH/TC2-2008/0107 [484],
XSH/TC2-2008/0108 [675], and XSH/TC2-2008/0109 [675,677] are applied.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_139_15" id="tag_17_139_15"></a>Issue 8</h4>
<blockquote>
<p>Austin Group Defect 695 is applied, adding an atomicity requirement to the F_SETOWN operation.</p>
<p>Austin Group Defects 768 and 1671 are applied, adding OFD-owned file locks.</p>
<p>Austin Group Defect 1203 is applied, changing some wording in the RETURN VALUE section to use &quot;shall&quot;.</p>
<p>Austin Group Defects 1274 and 1670 are applied, adding F_GETOWN_EX and F_SETOWN_EX.</p>
<p>Austin Group Defect 1318 is applied, adding FD_CLOFORK and F_DUPFD_CLOFORK.</p>
</blockquote>
<div class="box"><em>End of informative text.</em></div>
<hr>
<p>&nbsp;</p>
<a href="#top"><span class="topOfPage">return to top of page</span></a><br>
<hr size="2" noshade>
<center><font size="2">UNIX® is a registered Trademark of The Open Group.<br>
POSIX™ is a Trademark of The IEEE.<br>
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved<br>
[ <a href="../mindex.html">Main Index</a> | <a href="../basedefs/contents.html">XBD</a> | <a href=
"../functions/contents.html">XSH</a> | <a href="../utilities/contents.html">XCU</a> | <a href="../xrat/contents.html">XRAT</a>
]</font></center>
<hr size="2" noshade>
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/fclose.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/fdatasync.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>
<hr align="left" width="100%"></div>
</body>
</html>
