NOTE: we have stopped maintaining the x86 version of xv6, and switched
our efforts to the RISC-V version
(https://github.com/mit-pdos/xv6-riscv.git)

xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
Version 6 (v6).  xv6 loosely follows the structure and style of v6,
but is implemented for a modern x86-based multiprocessor using ANSI C.

The user-level shell supports built-in commands such as ``cd``.  These
built-ins execute directly in the shell process even when used in command
lists, pipelines, or background jobs.

ACKNOWLEDGMENTS

xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
2000)). See also https://pdos.csail.mit.edu/6.828/, which
provides pointers to on-line resources for v6.

xv6 borrows code from the following sources:
    JOS (asm.h, elf.h, mmu.h, bootasm.S, ide.c, console.c, and others)
    Plan 9 (entryother.S, mp.h, mp.c, lapic.c)
    FreeBSD (ioapic.c)
    NetBSD (console.c)

The following people have made contributions: Russ Cox (context switching,
locking), Cliff Frey (MP), Xiao Yu (MP), Nickolai Zeldovich, and Austin
Clements.

We are also grateful for the bug reports and patches contributed by Silas
Boyd-Wickizer, Anton Burtsev, Cody Cutler, Mike CAT, Tej Chajed, eyalz800,
Nelson Elhage, Saar Ettinger, Alice Ferrazzi, Nathaniel Filardo, Peter
Froehlich, Yakir Goaron,Shivam Handa, Bryan Henry, Jim Huang, Alexander
Kapshuk, Anders Kaseorg, kehao95, Wolfgang Keller, Eddie Kohler, Austin
Liew, Imbar Marinescu, Yandong Mao, Matan Shabtay, Hitoshi Mitake, Carmi
Merimovich, Mark Morrissey, mtasm, Joel Nider, Greg Price, Ayan Shafqat,
Eldar Sehayek, Yongming Shen, Cam Tenny, tyfkda, Rafael Ubal, Warren
Toomey, Stephen Tu, Pablo Ventura, Xi Wang, Keiichi Watanabe, Nicolas
Wolovick, wxdao, Grant Wu, Jindong Zhang, Icenowy Zheng, and Zou Chang Wei.

The code in the files that constitute xv6 is
Copyright 2006-2018 Frans Kaashoek, Robert Morris, and Russ Cox.

ERROR REPORTS

We don't process error reports (see note on top of this file).

BUILDING AND RUNNING XV6

To build xv6 on an x86 ELF machine (like Linux or FreeBSD), run
"make". On non-x86 or non-ELF machines (like OS X, even on x86), you
will need to install a cross-compiler gcc suite capable of producing
x86 ELF binaries (see https://pdos.csail.mit.edu/6.828/).
A cross-compiler may not be necessary on a 64-bit Linux host since the
toolchain can produce 32-bit binaries, but on other systems install a
cross-compiler suite and invoke ``make TOOLPREFIX=i386-jos-elf-``.  Now
install the QEMU PC simulator and run ``make qemu``.  The Bochs
emulator is also supported via ``make bochs`` and is installed by
``setup.sh``.
A helper script, `setup.sh`, installs cross-compilers, build dependencies,
QEMU packages, and additional development tools.  Run it once before
building to ensure all prerequisites are available.  From the top-level
directory simply execute::

    sudo ./setup.sh

This script installs bare-metal cross compiler packages such as
``gcc-i386-elf``/``g++-i386-elf`` and ``gcc-x86-64-elf``/``g++-x86-64-elf``
along with the rest of the toolchain.

This only needs to be done after cloning the repository or when
dependencies change.

Experimental support for building with the C23 standard and for
cross-compiling a 64-bit version is available. Set
``ARCH=x86_64`` when invoking make to enable 64-bit builds and adjust
``CSTD`` to use a different C standard if desired.


When building with ``ARCH=x86_64`` the resulting artifacts will be named
``kernel64``, ``fs64.img``, ``xv6-64.img`` and ``xv6memfs-64.img``.
Use these files when running QEMU or other emulators.

64-BIT BUILD REQUIREMENTS
-------------------------
Building a 64-bit kernel requires a cross-compiler capable of producing
``x86_64-elf`` binaries.  On most Linux systems this means installing
``x86_64-elf-gcc`` and the matching ``x86_64-elf`` binutils package.
If such packages are not available from your distribution you can build
them from source using the standard GNU build process.

Once a cross-compiler is installed, build the kernel with::

    make ARCH=x86_64

The resulting ``kernel.img`` can be run under QEMU with::

    make qemu ARCH=x86_64

The 64-bit port currently differs from the 32-bit version in a few
ways.  It is less thoroughly tested and some user-space tests may not
pass.  The memory layout also differs slightly in order to support 64-bit
addresses.

In 64-bit mode the kernel lives in the higher half of the address
space.  ``memlayout.h`` defines ``KERNBASE64`` at
``0xffffffff80000000`` with devices mapped near the top of the canonical
range starting at ``DEVSPACE64``.  ``PHYSTOP64`` specifies the upper
limit of usable physical memory.  When building for 64-bit these values
are selected automatically via conditional compilation and replace the
32-bit constants.

CODE FORMATTING
---------------
The project includes a ``.clang-format`` file configured for the LLVM
style with two-space indentation and the C23 language standard.  Before
submitting patches, run ``clang-format`` on any modified sources:

    clang-format -i file.c


EXO STREAMS
-----------
``struct exo_stream`` links scheduler modules together.  Register a stream
with ``exo_stream_register`` and call ``exo_stream_yield`` or
``exo_stream_halt`` to invoke the registered callbacks.  See the
``EXO_STREAM`` design note for details.  ``yield()`` invokes
``exo_stream_yield`` before scheduling another process.  When the
scheduler has no runnable tasks it calls ``exo_stream_halt`` rather
than spinning; the default implementation issues ``hlt`` if no stream
is registered.


USER DEMO: EXO_YIELD_TO AND STREAMS
-----------------------------------
The example program ``exo_stream_demo`` under ``src-uland/user/`` is a minimal
illustration of switching contexts with ``exo_yield_to`` and using the
placeholder STREAMS ``stop`` and ``yield`` calls.  Build the system as
usual with ``make``; the resulting ``fs.img`` will contain the new
``exo_stream_demo`` binary.  Run it inside QEMU to observe the stub
functions printing messages that indicate the expected invocation order.

USER DEMO: TYPED CHANNELS
-------------------------
``typed_chan_demo`` showcases the ``CHAN_DECLARE`` macro that creates a
typed wrapper around the basic capability IPC functions.  Messages are
defined using Cap'n Proto schemas under ``proto/`` and automatically
serialized when sending.  Building with ``make`` will compile
``typed_chan_demo`` along with ``typed_chan_send`` and
``typed_chan_recv`` under ``src-uland/user``.  After ``fs.img`` is
generated, run ``typed_chan_demo`` inside QEMU to see a Cap'n Proto
message sent and received through the typed channel API.

DRIVER SUPERVISOR
-----------------
``rcrs`` is a small supervisor that keeps user-space drivers running.
It parses ``/drivers.conf`` where each non-empty line lists a command
and arguments to execute.  Comment lines beginning with ``#`` are
ignored.  When a driver process exits the supervisor automatically
restarts it.  Add the desired commands to ``drivers.conf`` and place the
file in the file system image so ``init`` can launch ``rcrs`` early
during boot.

Example ``drivers.conf``::

    kbdserv
    otherdriver arg1 arg2


IPC DESIGN NOTE
---------------
See ``IPC.md`` for an overview of the fast-path call, capability badges,
and the proposed endpoint and typed channel features.

ENDPOINTS
---------
Endpoints are lightweight message channels inspired by Mach ports and
seL4 endpoints.  Each endpoint maintains an internal queue of
``zipc_msg_t`` values.  The ``endpoint_send`` and ``endpoint_recv``
system calls enqueue and dequeue messages, with receivers sleeping until
a message is available.  This allows asynchronous waiting similar to the
channel primitives in those microkernels.

NUMA-AWARE ALLOCATOR
--------------------
The page allocator now keeps a separate free list per NUMA node.  A
process can request a preferred node with the ``set_numa_node`` system
call.  ``kalloc()`` first attempts to allocate from the preferred node
and falls back to the other nodes only when the local free list is
empty.



See doc/phoenixkernel.md for a design overview of the Phoenix exokernel.

Example supervisor usage to manage drivers:

```
$ supervisor start blk_driver
... later ...
$ supervisor restart blk_driver
```
