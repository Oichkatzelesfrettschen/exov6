<!-- Copyright 2001-2024 IEEE and The Open Group, All Rights Reserved -->
<!DOCTYPE HTML>
<html lang="en">
<head>
<meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.8.0">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link type="text/css" rel="stylesheet" href="style.css"><!-- Generated by The Open Group rhtm tool v1.2.4 -->
<!-- Copyright (c) 2001-2024 The Open Group, All Rights Reserved -->
<title>posix_getdents</title>
</head>
<body bgcolor="white">
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/posix_fallocate.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/posix_madvise.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>
<hr align="left" width="100%"></div>
<script language="JavaScript" src="../jscript/codes.js"></script><basefont size="3">
<center><font size="2">The Open Group Base Specifications Issue 8<br>
IEEE Std 1003.1-2024<br>
Copyright © 2001-2024 The IEEE and The Open Group</font></center>
<hr size="2" noshade>
<a name="top" id="top"></a> <a name="posix_getdents" id="posix_getdents"></a> <a name="tag_17_383" id="tag_17_383"></a>
<!-- posix_getdents -->
<h4 class="mansect"><a name="tag_17_383_01" id="tag_17_383_01"></a>NAME</h4>
<blockquote>posix_getdents — read directory entries</blockquote>
<h4 class="mansect"><a name="tag_17_383_02" id="tag_17_383_02"></a>SYNOPSIS</h4>
<blockquote class="synopsis">
<p><code><tt>#include &lt;<a href="../basedefs/dirent.h.html">dirent.h</a>&gt;<br>
<br>
ssize_t posix_getdents(int</tt> <i>fildes</i><tt>, void *</tt><i>buf</i><tt>, size_t</tt> <i>nbyte</i><tt>, int</tt>
<i>flags</i><tt>);<br></tt></code></p>
</blockquote>
<h4 class="mansect"><a name="tag_17_383_03" id="tag_17_383_03"></a>DESCRIPTION</h4>
<blockquote>
<p>The <i>posix_getdents</i>() function shall attempt to read directory entries from the directory associated with the open file
descriptor <i>fildes</i> and shall place information about the directory entries and the files they refer to in <b>posix_dent</b>
structures in the buffer pointed to by <i>buf</i>, up to a maximum of <i>nbyte</i> bytes. The number of <b>posix_dent</b>
structures populated in <i>buf</i> may be fewer than the number that will fit in <i>nbyte</i> bytes, but shall be at least one if
<i>nbyte</i> is greater than the size of the <b>posix_dent</b> structure plus {NAME_MAX} and <i>fildes</i> is not currently at
end-of-file.</p>
<p>The application shall ensure that <i>buf</i> is aligned suitably to point to a <b>posix_dent</b> structure. The alignment needed
shall not be more restrictive than the alignment provided by <a href="../functions/malloc.html"><i>malloc</i>()</a>. Strictly
conforming applications shall ensure that the value of <i>flags</i> is zero; other applications can set it to a value constructed
by a bitwise-inclusive OR of implementation-defined bitwise-distinct flag values.</p>
<p>Each <b>posix_dent</b> structure returned in <i>buf</i> shall be located at an address that satisfies the implementation's
alignment requirements for the <b>posix_dent</b> structure and shall be populated as follows:</p>
<ul>
<li>
<p>The value of the <i>d_ino</i> member shall be set to the file serial number of the file named by the <i>d_name</i> member.</p>
</li>
<li>
<p>The value of the <i>d_reclen</i> member shall be set to the number of bytes occupied by this entry in <i>buf</i>, including any
padding bytes needed before the next entry, if any. If this is the last entry in <i>buf</i>, <i>d_reclen</i> shall include any
padding bytes needed to make the address of this entry plus <i>d_reclen</i> bytes satisfy the alignment requirements for the
<b>posix_dent</b> structure.</p>
</li>
<li>
<p>The value of the <i>d_type</i> member shall be set to indicate the file type of the named file, if the file type can be
determined without needing to use the file serial number to obtain the file's metadata; otherwise it may be set to DT_UNKNOWN. If
the file type is determined and it is one of the file types defined in this standard, the value of <i>d_type</i> shall be DT_BLK,
DT_CHR, DT_DIR, DT_FIFO, DT_LNK, DT_REG, DT_SOCK, DT_MQ, DT_SEM, DT_SHM, <sup>[<a href="javascript:open_code('TYM')">TYM</a>]</sup>
<img src="../images/opt-start.gif" alt="[Option Start]" border="0"> &nbsp;or DT_TMO <img src="../images/opt-end.gif" alt=
"[Option End]" border="0"> &nbsp;(see <a href="../basedefs/dirent.h.html"><i>&lt;dirent.h&gt;</i></a>). If it is determined but is
not a standard file type, the value of <i>d_type</i> shall not equal any of those listed here.</p>
</li>
<li>
<p>The <i>d_name</i> member shall be a filename string, and (if not dot or dot-dot) shall contain the same byte sequence as the
last pathname component of the string used to create the directory entry, plus the terminating NUL byte.</p>
</li>
</ul>
<p>If the <i>d_name</i> member names a symbolic link, the values of the <i>d_ino</i> and <i>d_type</i> members shall be set to the
values for the symbolic link itself.</p>
<p>The <i>posix_getdents</i>() function shall start reading at the current file offset in the open file description associated with
<i>fildes</i>. On successful return, the file offset shall be incremented to point to the directory entry immediately following the
last entry whose information was returned in <i>buf</i>, or to point to end-of-file if there are no more directory entries. On
failure, the value of the file offset is unspecified. The current file offset can be set and retrieved using <a href=
"../functions/lseek.html"><i>lseek</i>()</a> on the open file description associated with <i>fildes</i>. The behavior is
unspecified if <a href="../functions/lseek.html"><i>lseek</i>()</a> is used to set the file offset to a value other than zero or a
value returned by a previous call to <a href="../functions/lseek.html"><i>lseek</i>()</a> on the same open file description.</p>
<p>The <i>posix_getdents</i>() function shall not return directory entries containing empty names. If entries for dot or dot-dot
exist, a sequence of calls that reads from offset zero to end-of-file shall return one entry for dot and one entry for dot-dot;
otherwise, they shall not be returned.</p>
<p>Upon successful completion, <i>posix_getdents</i>() shall mark for update the last data access timestamp of the directory.</p>
<p>If <i>fildes</i> is a file descriptor associated with a directory stream opened using <a href=
"../functions/fdopendir.html"><i>fdopendir</i>()</a> or <a href="../functions/opendir.html"><i>opendir</i>()</a>, the behavior is
unspecified.</p>
<p>If <i>posix_getdents</i>() is called concurrently with an operation that adds, deletes, or modifies a directory entry, the
results from <i>posix_getdents</i>() shall reflect either all of the effects of the concurrent operation or none of them. If a
sequence of calls to <i>posix_getdents</i>() is made that reads from offset zero to end-of-file and a file is removed from or added
to the directory between the first and last of those calls, whether the sequence of calls returns an entry for that file is
unspecified.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_383_04" id="tag_17_383_04"></a>RETURN VALUE</h4>
<blockquote>
<p>Upon successful completion, either a non-negative integer shall be returned indicating the number of bytes occupied by the
<b>posix_dent</b> structures placed in <i>buf</i> or 0 shall be returned indicating the end of the directory was reached without
any directory entries being placed in <i>buf</i>. Otherwise, -1 shall be returned and <i>errno</i> shall be set to indicate the
error.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_383_05" id="tag_17_383_05"></a>ERRORS</h4>
<blockquote>
<p>The <i>posix_getdents</i>() function shall fail if:</p>
<dl compact>
<dd></dd>
<dt>[EBADF]</dt>
<dd>The <i>fildes</i> argument is not a valid file descriptor open for reading.</dd>
<dt>[EINVAL]</dt>
<dd>The <i>nbyte</i> argument is not large enough to contain the information to be returned about the directory entry located at
the current file offset.</dd>
<dt>[ENOENT]</dt>
<dd>The current file offset is not located at a valid directory entry.</dd>
<dt>[ENOTDIR]</dt>
<dd>The <i>fildes</i> argument is associated with a non-directory file.</dd>
<dt>[EOVERFLOW]</dt>
<dd>One of the values in a structure to be placed in <i>buf</i> cannot be represented correctly.</dd>
</dl>
<p>The <i>posix_getdents</i>() function may fail if:</p>
<dl compact>
<dd></dd>
<dt>[EIO]</dt>
<dd>A physical I/O error has occurred.</dd>
<dt>[ENOMEM]</dt>
<dd>Insufficient memory was available to fulfill the request.</dd>
</dl>
</blockquote>
<hr>
<div class="box"><em>The following sections are informative.</em></div>
<h4 class="mansect"><a name="tag_17_383_06" id="tag_17_383_06"></a>EXAMPLES</h4>
<blockquote>
<p>This example function lists the files in a specified directory with their file serial number and file type. If the file type is
not available from <i>posix_getdents</i>(), it is obtained using <a href="../functions/fstatat.html"><i>fstatat</i>()</a>.</p>
<pre>
<tt>#include &lt;dirent.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
<br>
#define ENTBUFSIZ 10240
<br>
int list_dir(const char *dirnam)
{
    int fd = open(dirnam, O_RDONLY | O_DIRECTORY);
    if (fd == -1)
        return -1;
<br>
    char *buf = malloc(ENTBUFSIZ);
    if (buf == NULL)
    {
        close(fd);
        return -1;
    }
<br>
    ssize_t bytesinbuf;
    for(;;)
    {
        ssize_t nextent = 0;
<br>
        bytesinbuf = posix_getdents(fd, buf, ENTBUFSIZ, 0);
        if (bytesinbuf &lt;= 0)
            break;
<br>
        do {
            const char *ftype;
            struct posix_dent *entp = (void *)&amp;buf[nextent];
            if (entp-&gt;d_type == DT_UNKNOWN)
            {
                struct stat stbuf;
                if (fstatat(fd, entp-&gt;d_name, &amp;stbuf,
                            AT_SYMLINK_NOFOLLOW) == -1)
                    ftype = "?";
                else
                    ftype = S_ISBLK(stbuf.st_mode) ? "b" :
                         S_ISCHR(stbuf.st_mode) ? "c" :
                         S_ISDIR(stbuf.st_mode) ? "d" :
                         S_ISFIFO(stbuf.st_mode) ? "p" :
                         S_ISLNK(stbuf.st_mode) ? "l" :
                         S_ISREG(stbuf.st_mode) ? "r" :
                         S_ISSOCK(stbuf.st_mode) ? "s" :
                         S_TYPEISMQ(&amp;stbuf) ? "mq" :
                         S_TYPEISSEM(&amp;stbuf) ? "sem" :
                         S_TYPEISSHM(&amp;stbuf) ? "shm" :
#ifdef S_TYPEISTMO
                         S_TYPEISTMO(&amp;stbuf) ? "tmo" :
#endif
                         "?";
            }
            else
            {
                ftype = entp-&gt;d_type == DT_BLK ? "b" :
                        entp-&gt;d_type == DT_CHR ? "c" :
                        entp-&gt;d_type == DT_DIR ? "d" :
                        entp-&gt;d_type == DT_FIFO ? "p" :
                        entp-&gt;d_type == DT_LNK ? "l" :
                        entp-&gt;d_type == DT_REG ? "r" :
                        entp-&gt;d_type == DT_SOCK ? "s" :
                        entp-&gt;d_type == DT_MQ ? "mq" :
                        entp-&gt;d_type == DT_SEM ? "sem" :
                        entp-&gt;d_type == DT_SHM ? "shm" :
#ifdef DT_TMO
                        entp-&gt;d_type == DT_TMO ? "tmo" :
#endif
                        "?";
            }
<br>
            printf("%ld\t%s\t%s\n", (long)entp-&gt;d_ino, ftype,
                entp-&gt;d_name);
<br>
            nextent += entp-&gt;d_reclen;
<br>
        } while (nextent &lt; bytesinbuf);
    }
<br>
    close(fd);
    free(buf);
    return bytesinbuf;
}
</tt></pre></blockquote>
<h4 class="mansect"><a name="tag_17_383_07" id="tag_17_383_07"></a>APPLICATION USAGE</h4>
<blockquote>
<p>If an array of <b>posix_dent</b> structures (which is only possible on implementations where <i>d_name</i> is not a flexible
array member) is used to provide the storage for <i>buf</i> in order to satisfy the alignment requirement, it should be noted that
the number of array elements used to size the array may bear little or no relation to the number of directory entries that can be
stored in it. It is recommended that the number of elements is calculated from the desired size in bytes, for example:</p>
<pre>
<tt>#define DESIREDSIZE 10240
struct posix_dent buf[DESIREDSIZE / sizeof(struct posix_dent) + 1];
size_t nbyte = sizeof buf;
</tt></pre>
<p>When <i>posix_getdents</i>() is called with a <i>buf</i> that is not type <b>char *</b>, it is important to note that
<i>d_reclen</i> is a byte count and therefore any pointer arithmetic involved in calculating the start of the next entry needs to
use a <b>char *</b> pointer.</p>
<p>On implementations where directory entries in a directory take up more space than the corresponding <b>posix_dent</b> structures
in <i>buf</i>, a call to <i>posix_getdents</i>() may read <i>nbyte</i> bytes from the directory, resulting (in most cases) in the
actual number of bytes placed in <i>buf</i> being less than <i>nbyte</i>.</p>
<p>One advantage of <i>posix_getdents</i>() is that it provides the file type of each directory entry (if available), whereas
<a href="../functions/readdir.html"><i>readdir</i>()</a> only does so on implementations that have the file type as a non-standard
additional member of the <b>dirent</b> structure. Knowing the file type can greatly reduce the number of <a href=
"../functions/fstatat.html"><i>fstatat</i>()</a> calls that need to be made when traversing the file hierarchy.</p>
<p>Whether or not a file's type can be determined without needing to use the file serial number to obtain the file's metadata may
vary across the different file system types supported by an implementation. Therefore applications should not assume that if
<i>d_type</i> contains known file types (i.e. not DT_UNKNOWN) for entries in a given directory then it will also contain known file
types for entries in subdirectories of that directory or in its parent.</p>
<p>Since the <i>d_reclen</i> value for the last entry in <i>buf</i> includes padding to satisfy alignment requirements,
applications can grow the buffer and call <i>posix_getdents</i>() again to append to it without needing to perform an alignment
calculation.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_383_08" id="tag_17_383_08"></a>RATIONALE</h4>
<blockquote>
<p>The <i>posix_getdents</i>() function was derived from existing <i>getdents</i>() functions but the name was changed because the
existing <i>getdents</i>() functions differed in various ways, in particular the type of the second argument (structure pointer or
<b>void *</b>), the members of the populated structures, and the error numbers used for some conditions. The name change also
provided an opportunity to add a <i>flags</i> argument to provide for future extensibility.</p>
<p>Implementations are encouraged to include support for a DT_FORCE_TYPE flag which, when that bit is set in <i>flags</i>, causes
<i>posix_getdents</i>() to look up the file type if it can not be obtained from the directory entry. This will allow applications
that need to know the file type of every directory entry to keep the cost of these lookups to the minimum needed to obtain the type
at the file system level, without the additional overhead of making a call to <a href=
"../functions/fstatat.html"><i>fstatat</i>()</a> for every file (that has <i>d_type</i> equal to DT_UNKNOWN).</p>
<p>Some existing <i>getdents</i>() or similar functions return directory entry structures for deleted directory entries in
<i>buf</i>, marked with a special value of one of the structure members to distinguish them from non-deleted entries. This behavior
is not allowed for <i>posix_getdents</i>(), although the data from a deleted directory entry may be present in <i>buf</i> in the
form of extra padding on the end of the previous entry.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_383_09" id="tag_17_383_09"></a>FUTURE DIRECTIONS</h4>
<blockquote>
<p>A future version of this standard may add a DT_FORCE_TYPE flag as described in RATIONALE.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_383_10" id="tag_17_383_10"></a>SEE ALSO</h4>
<blockquote>
<p><a href="../functions/fdopendir.html#"><i>fdopendir</i>()</a>, <a href="../functions/fstatat.html#"><i>fstatat</i>()</a>,
<a href="../functions/lseek.html#"><i>lseek</i>()</a>, <a href="../functions/readdir.html#"><i>readdir</i>()</a></p>
<p>XBD <a href="../basedefs/dirent.h.html"><i>&lt;dirent.h&gt;</i></a></p>
</blockquote>
<h4 class="mansect"><a name="tag_17_383_11" id="tag_17_383_11"></a>CHANGE HISTORY</h4>
<blockquote>
<p>First released in Issue 8.</p>
</blockquote>
<div class="box"><em>End of informative text.</em></div>
<hr>
<p>&nbsp;</p>
<a href="#top"><span class="topOfPage">return to top of page</span></a><br>
<hr size="2" noshade>
<center><font size="2">UNIX® is a registered Trademark of The Open Group.<br>
POSIX™ is a Trademark of The IEEE.<br>
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved<br>
[ <a href="../mindex.html">Main Index</a> | <a href="../basedefs/contents.html">XBD</a> | <a href=
"../functions/contents.html">XSH</a> | <a href="../utilities/contents.html">XCU</a> | <a href="../xrat/contents.html">XRAT</a>
]</font></center>
<hr size="2" noshade>
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/posix_fallocate.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/posix_madvise.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>
<hr align="left" width="100%"></div>
</body>
</html>
