<!-- Copyright 2001-2024 IEEE and The Open Group, All Rights Reserved -->
<!DOCTYPE HTML>
<html lang="en">
<head>
<meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.8.0">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link type="text/css" rel="stylesheet" href="style.css"><!-- Generated by The Open Group rhtm tool v1.2.4 -->
<!-- Copyright (c) 2001-2024 The Open Group, All Rights Reserved -->
<title>popen</title>
</head>
<body bgcolor="white">
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/poll.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/posix_devctl.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>
<hr align="left" width="100%"></div>
<script language="JavaScript" src="../jscript/codes.js"></script><basefont size="3">
<center><font size="2">The Open Group Base Specifications Issue 8<br>
IEEE Std 1003.1-2024<br>
Copyright © 2001-2024 The IEEE and The Open Group</font></center>
<hr size="2" noshade>
<a name="top" id="top"></a> <a name="popen" id="popen"></a> <a name="tag_17_379" id="tag_17_379"></a><!-- popen -->
<h4 class="mansect"><a name="tag_17_379_01" id="tag_17_379_01"></a>NAME</h4>
<blockquote>popen — initiate pipe streams to or from a process</blockquote>
<h4 class="mansect"><a name="tag_17_379_02" id="tag_17_379_02"></a>SYNOPSIS</h4>
<blockquote class="synopsis">
<div class="box"><code><tt><sup>[<a href="javascript:open_code('CX')">CX</a>]</sup> <img src="../images/opt-start.gif" alt=
"[Option Start]" border="0"> #include &lt;<a href="../basedefs/stdio.h.html">stdio.h</a>&gt;<br>
<br>
FILE *popen(const char *</tt><i>command</i><tt>, const char *</tt><i>mode</i><tt>); <img src="../images/opt-end.gif" alt=
"[Option End]" border="0"></tt></code></div>
<tt><br></tt></blockquote>
<h4 class="mansect"><a name="tag_17_379_03" id="tag_17_379_03"></a>DESCRIPTION</h4>
<blockquote>
<p>The <i>popen</i>() function shall execute the command specified by the string <i>command</i>. It shall create a pipe between the
calling program and the executed command, and shall return a pointer to a stream that can be used to either read from or write to
the pipe.</p>
<p>The environment of the executed command shall be as if a child process were created within the <i>popen</i>() call using the
<a href="../functions/fork.html"><i>fork</i>()</a> function, and the child invoked the <a href="../utilities/sh.html"><i>sh</i></a>
utility using the call:</p>
<pre>
<tt>execl(&lt;</tt><i>shell path</i><tt>&gt;, "sh", "-c", "--", </tt><i>command</i><tt>, (char *)0);
</tt></pre>
<p>where &lt;<i>shell path</i>&gt; is an unspecified pathname for the <a href="../utilities/sh.html"><i>sh</i></a> utility. It is
implementation-defined whether the handlers registered with <a href="../functions/pthread_atfork.html"><i>pthread_atfork</i>()</a>
are called as part of the creation of the child process.</p>
<p>The <i>popen</i>() function shall ensure that any streams from previous <i>popen</i>() calls that remain open in the parent
process are closed in the new child process, regardless of the FD_CLOEXEC or FD_CLOFORK status of the file descriptor underlying
those streams.</p>
<p>The <i>mode</i> argument to <i>popen</i>() is a string that specifies I/O mode:</p>
<ol>
<li>
<p>If <i>mode</i> starts with <tt>'r'</tt>, when the child process is started, its file descriptor STDOUT_FILENO shall be the
writable end of the pipe, and the file descriptor <i>fileno</i>(<i>stream</i>) in the calling process, where <i>stream</i> is the
stream pointer returned by <i>popen</i>(), shall be the readable end of the pipe. The FD_CLOFORK flag shall be cleared on both the
STDOUT_FILENO file descriptor passed to the child process and the file descriptor underlying the returned stream.</p>
</li>
<li>
<p>If <i>mode</i> starts with <tt>'w'</tt>, when the child process is started its file descriptor STDIN_FILENO shall be the
readable end of the pipe, and the file descriptor <i>fileno</i>(<i>stream</i>) in the calling process, where <i>stream</i> is the
stream pointer returned by <i>popen</i>(), shall be the writable end of the pipe. The FD_CLOFORK flag shall be cleared on both the
STDOUT_FILENO file descriptor passed to the child process and the file descriptor underlying the returned stream.</p>
</li>
<li>
<p>If <i>mode</i> includes a second character of <tt>'e'</tt>, then the file descriptor underlying the stream returned to the
calling process by <i>popen</i>() shall have the FD_CLOEXEC flag atomically set. Additionally, if the implementation creates the
file descriptor for use by the child process from within the parent process, then that file descriptor shall have the FD_CLOEXEC
flag atomically set within the parent process. If <i>mode</i> does not have a second character, the FD_CLOEXEC flag of the
underlying file descriptor returned by <i>popen</i>() shall be clear.</p>
</li>
<li>
<p>If <i>mode</i> is any other value, the result is unspecified.</p>
</li>
</ol>
<p>After <i>popen</i>(), both the parent and the child process shall be capable of executing independently before either
terminates.</p>
<p>Pipe streams are byte-oriented.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_379_04" id="tag_17_379_04"></a>RETURN VALUE</h4>
<blockquote>
<p>Upon successful completion, <i>popen</i>() shall return a pointer to an open stream that can be used to read or write to the
pipe. Otherwise, it shall return a null pointer and may set <i>errno</i> to indicate the error.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_379_05" id="tag_17_379_05"></a>ERRORS</h4>
<blockquote>
<p>The <i>popen</i>() function shall fail if:</p>
<dl compact>
<dd></dd>
<dt>[EMFILE]</dt>
<dd>{STREAM_MAX} streams are currently open in the calling process.</dd>
</dl>
<p>The <i>popen</i>() function may fail if:</p>
<dl compact>
<dd></dd>
<dt>[EMFILE]</dt>
<dd>{FOPEN_MAX} streams are currently open in the calling process.</dd>
<dt>[EINVAL]</dt>
<dd>The <i>mode</i> argument is invalid.</dd>
</dl>
<p>The <i>popen</i>() function may also set <i>errno</i> values as described by <a href="../functions/fork.html#"><i>fork</i>()</a>
or <a href="../functions/pipe.html#"><i>pipe</i>()</a>.</p>
</blockquote>
<hr>
<div class="box"><em>The following sections are informative.</em></div>
<h4 class="mansect"><a name="tag_17_379_06" id="tag_17_379_06"></a>EXAMPLES</h4>
<blockquote>
<h5><a name="tag_17_379_06_01" id="tag_17_379_06_01"></a>Using popen() to Obtain a List of Files from the ls Utility</h5>
<p>The following example demonstrates the use of <i>popen</i>() and <a href="../functions/pclose.html"><i>pclose</i>()</a> to
execute the command <a href="../utilities/ls.html"><i>ls</i></a>* in order to obtain a list of files in the current directory:</p>
<pre>
<tt>#include &lt;stdio.h&gt;
...
<br>
FILE *fp;
int status;
char path[PATH_MAX];
<br>
fp = popen("ls *", "r");
if (fp == NULL)
    /* Handle error */;
<br>
while (fgets(path, PATH_MAX, fp) != NULL)
    printf("%s", path);
<br>
status = pclose(fp);
if (status == -1) {
    /* Error reported by pclose() */
    ...
} else {
    /* Use macros described under wait() to inspect `status' in order
       to determine success/failure of command executed by popen() */
    ...
}
</tt></pre></blockquote>
<h4 class="mansect"><a name="tag_17_379_07" id="tag_17_379_07"></a>APPLICATION USAGE</h4>
<blockquote>
<p>Since open files are shared, a mode <tt>'r'</tt> command can be used as an input filter and a mode <tt>'w'</tt> command as an
output filter.</p>
<p>Buffered reading before opening an input filter may leave the standard input of that filter mispositioned. Similar problems with
an output filter may be prevented by careful buffer flushing; for example, with <a href=
"../functions/fflush.html#"><i>fflush</i>()</a>.</p>
<p>A stream opened by <i>popen</i>() should be closed by <a href="../functions/pclose.html"><i>pclose</i>()</a>.</p>
<p>The behavior of <i>popen</i>() is specified for values of <i>mode</i> of <tt>"r"</tt>, <tt>"w"</tt>, <tt>"re"</tt>, and
<tt>"we"</tt>. Other modes such as <tt>"rb"</tt> and <tt>"wb"</tt> might be supported by specific implementations, but these would
not be portable features. Note that historical implementations of <i>popen</i>() only check to see if the first character of
<i>mode</i> is <tt>'r'</tt>. Thus, a <i>mode</i> of <tt>"robert the robot"</tt> would be treated as <i>mode</i> <tt>"r"</tt>, and a
<i>mode</i> of <tt>"anything else"</tt> would be treated as <i>mode</i> <tt>"w"</tt>.</p>
<p>If the application calls <a href="../functions/waitpid.html"><i>waitpid</i>()</a> or <a href=
"../functions/waitid.html"><i>waitid</i>()</a> with a <i>pid</i> argument greater than 0, and it still has a stream that was called
with <i>popen</i>() open, it must ensure that <i>pid</i> does not refer to the process started by <i>popen</i>().</p>
<p>To determine whether or not the environment specified in the Shell and Utilities volume of POSIX.1-2024 is present, use the
function call:</p>
<pre>
<tt>sysconf(_SC_2_VERSION)
</tt></pre>
<p>(See <a href="../functions/sysconf.html#"><i>sysconf</i>()</a>).</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_379_08" id="tag_17_379_08"></a>RATIONALE</h4>
<blockquote>
<p>The <i>popen</i>() function should not be used by programs that have set user (or group) ID privileges. The <a href=
"../functions/fork.html"><i>fork</i>()</a> and <i><a href="../functions/exec.html">exec</a></i> family of functions (except
<a href="../functions/execlp.html"><i>execlp</i>()</a> and <a href="../functions/execvp.html"><i>execvp</i>()</a>), should be used
instead. This prevents any unforeseen manipulation of the environment of the user that could cause execution of commands not
anticipated by the calling program.</p>
<p>If the original and <i>popen</i>()ed processes both intend to read or write or read and write a common file, and either will be
using FILE-type C functions (<a href="../functions/fread.html"><i>fread</i>()</a>, <a href=
"../functions/fwrite.html"><i>fwrite</i>()</a>, and so on), the rules for sharing file handles must be observed (see <a href=
"../functions/V2_chap02.html#tag_16_05_01"><i>2.5.1 Interaction of File Descriptors and Standard I/O Streams</i></a>).</p>
<p>The <tt>'e'</tt> mode modifier to <i>popen</i>() is necessary to avoid a data race in multi-threaded applications. Without it,
the parent's file descriptor is leaked into a second child process created by one thread in the window between another thread
creating the pipe via <i>popen</i>() then using <a href="../functions/fileno.html"><i>fileno</i>()</a> and <a href=
"../functions/fcntl.html"><i>fcntl</i>()</a> on the result. Also, if the <i>popen</i>() implementation temporarily has the child's
file descriptor open within the parent, then that file descriptor could also be leaked if it is not atomically FD_CLOEXEC for the
duration in which it is open in the parent.</p>
<p>The standard only requires that the implementation atomically set FD_CLOEXEC on file descriptors created in the parent process
when the <tt>'e'</tt> mode modifier is in effect; implementations may also do so when the <tt>'e'</tt> modifier is not in use,
provided that the FD_CLOEXEC bit is eventually cleared before <i>popen</i>() completes, however, this is not required because any
application worried about the potential file descriptor leak will already be using the <tt>'e'</tt> modifier.</p>
<p>Implementations are encouraged to add support for a <tt>"wf"</tt> mode which creates the pipe as if by calling <a href=
"../functions/pipe2.html"><i>pipe2</i>()</a> with the O_CLOFORK flag and then clearing FD_CLOFORK for the read side of the pipe.
This prevents the write side from leaking into child processes created by other threads, ensuring the child created by
<i>popen</i>() will get end-of-file when the parent closes the write side (although the read side can still be leaked).
Unfortunately there is no way (short of temporarily preventing other threads from creating child processes, or implementing an
atomic create-pipe-and-fork system call) to implement an <tt>"rf"</tt> mode with the equivalent guarantee that the child created by
<i>popen</i>() will be the only writer. Therefore multi-threaded applications that do not have complete control over process
creation cannot rely on getting end-of-file on the stream and need to use an alternative method of indicating the end of
communications.</p>
<p>Although the standard is clear that a conforming application should not call <i>popen</i>() when file descriptor 0 or 1 is
closed, implementations are encouraged to handle these cases correctly.</p>
<p>The following two examples demonstrate possible implementations of <i>popen</i>() using other standard functions. These examples
are designed to show FD_CLOEXEC handling rather than all aspects of thread safety, and implementations are encouraged to improve
the locking mechanism around the state list to be more efficient, as well as to be more robust if file descriptor 0 or 1 is
returned as either part of the pipe. Also, remember that other implementations are possible, including one that uses an
implementation-specific means of creating a pipe between parent and child where the parent process never has access to the child's
end of the pipe. Both of these examples make use of the following helper functions, documented but not implemented here, to do the
bookkeeping necessary to properly close all file descriptors created by other <i>popen</i>() calls regardless of their FD_CLOEXEC
or FD_CLOFORK status:</p>
<pre>
<tt>/* Obtain mutual exclusion lock, so that no concurrent popen() or
   pclose() calls are simultaneously modifying the list of tracked
   children. */
static void popen_lock(void);
<br>
/* Release mutual exclusion lock, without changing errno. */
static void popen_unlock(void);
<br>
/* Add the pid and stream pair to the list of tracked children, prior
   to any code that can clear FD_CLOEXEC on the file descriptor
   associated with stream. To be used while holding the lock. */
static void popen_add_pair(FILE *stream, pid_t pid);
<br>
/* Given a stream, return the associated pid, or -1 with errno set if
   the stream was not created by popen(). To be used while holding
   the lock. */
static pid_t popen_get_pid(FILE *stream);
<br>
/* Remove stream and its corresponding pid from the list of tracked
   children. To be used while holding the lock. */
static void popen_remove(FILE *stream);
<br>
/* If stream is NULL, return the first tracked child; otherwise,
   return the next tracked child. Return NULL if all tracked children
   have been returned. To be used while holding the lock. */
static FILE *popen_next(FILE *stream);
</tt></pre>
<p>The first example is based on <a href="../functions/fork.html"><i>fork</i>()</a>:</p>
<pre>
<tt>#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;unistd.h&gt;
FILE *popen(const char *command, const char *mode)
{
  int fds[2];
  pid_t pid;
  FILE *stream;
  int target = mode[0] == 'w'; /* index of fds used by parent */
<br>
  /* Validate mode */
  if ((mode[0] != 'w' &amp;& mode[0] != 'r') ||
      mode[1 + (mode[1] == 'e')]) {
    errno = EINVAL;
    return NULL;
  }
<br>
  /* Create pipe and stream with FD_CLOEXEC set */
  if (pipe2(fds, O_CLOEXEC) &lt; 0)
    return NULL;
  stream = fdopen(fds[target], mode);
  if (!stream) {
    int saved = errno;
    close(fds[0]);
    close(fds[1]);
    errno = saved;
    return NULL;
  }
<br>
  /* Create child process */
  popen_lock();
  pid = fork();
  if (pid &lt; 0) {
    int saved = errno;
    close(fds[!target]);
    fclose(stream);
    popen_unlock();
    errno = saved;
    return NULL;
  }
<br>
  /* Child process. */
  if (!pid) {
    FILE *tracked = popen_next(NULL);
    while (tracked) {
      int fd = fileno(tracked);
      if (fd &lt; 0 || close(fd))
        _exit(127);
      tracked = popen_next(tracked);
    }
    target = mode[0] == 'r'; /* Opposite fd in the child */
    /* Use dup2 or fcntl to clear FD_CLOEXEC on child's descriptor,
       FD_CLOEXEC will take care of the rest of fds[]. */
    if (fds[target] != target) {
      if (dup2(fds[target], target) != target)
        _exit(127);
    } else {
      int flags = fcntl(fds[target], F_GETFD);
      if (flags &lt; 0 ||
          fcntl(fds[target], F_SETFD, flags & ~FD_CLOEXEC) &lt; 0)
        _exit(127);
    }
    execl("/bin/sh", "sh", "-c", "--", command, NULL);
    _exit(127);
  }
<br>
  /* Parent process. From here on out, the close and fcntl system
     calls are assumed to pass, since all inputs are valid and do not
     require allocating any fds or memory. Besides, excluding
     failures due to undefined behavior (such as another thread
     closing an fd it knows nothing about), cleanup from any defined
     failures would require stopping and reaping the child process,
     which may have worse consequences. */
  close(fds[!target]);  popen_add_pair(stream, pid);
  popen_unlock();
  if (mode[1] != 'e') {
    int flags = fcntl(fds[target], F_GETFD);
    if (flags &gt;= 0)
      fcntl(fds[target], F_SETFD, flags & ~FD_CLOEXEC);
  }
  return stream;
}
</tt></pre>
<p>The second example is based on <a href="../functions/posix_spawn.html"><i>posix_spawn</i>()</a>:</p>
<pre>
<tt>#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;unistd.h&gt;
#include &lt;spawn.h&gt;
extern char **environ;
FILE *popen(const char *command, const char *mode)
{
  int fds[2];
  pid_t pid;
  FILE *stream;
  int target = mode[0] == 'w'; /* index of fds used by parent */
  const char *argv[] = { "sh", "-c", "--", command, NULL };
  posix_spawn_file_actions_t actions;
  int saved;
  FILE *tracked;
<br>
  /* Validate mode */
  if ((mode[0] != 'w' &amp;& mode[0] != 'r') ||
      mode[1 + (mode[1] == 'e')]) {
    errno = EINVAL;
    return NULL;
  }
<br>
  /* Create pipe and stream with FD_CLOEXEC set */
  if (pipe2(fds, O_CLOEXEC) &lt; 0)
    return NULL;
  stream = fdopen(fds[target], mode);
  if (!stream) {
    saved = errno;
    close(fds[0]);
    close(fds[1]);
    errno = saved;
    return NULL;
  }
<br>
  /* Create child process */
  if (posix_spawn_file_actions_init(&amp;actions)) {
    saved = errno;
    goto spawnerr1;
  }
  popen_lock();
  tracked = popen_next(NULL);
  while (tracked) {
    int fd = fileno(tracked);
    if (fd &lt; 0 || posix_spawn_file_actions_addclose(&amp;actions, fd))
      goto spawnerr2;
    tracked = popen_next(tracked);
  }
  if (posix_spawn_file_actions_adddup2(&amp;actions, fds[!target], !target))
    goto spawnerr2;
  if (posix_spawn(&amp;pid, "/bin/sh", &amp;actions, NULL, (char **)argv, 
environ)) {
spawnerr2:
    saved = errno;
    posix_spawn_file_actions_destroy(&amp;actions);
    popen_unlock();
spawnerr1:
    close(fds[!target]);
    fclose(stream);
    errno = saved;
    return NULL;
  }
<br>
  /* From here on out, system calls are assumed to pass, since all
     inputs are valid and do not require allocating any fds or memory.
     Besides, excluding failures due to undefined behavior (such as
     another thread closing an fd it knows nothing about), cleanup
     from any defined failures would require stopping and reaping the
     child process, which may have worse consequences. */
  posix_spawn_file_actions_destroy(&amp;actions);
  close(fds[!target]);
  popen_add_pair(stream, pid);
  popen_unlock();
  if (mode[1] != 'e') {
    int flags = fcntl(fds[target], F_GETFD);
    if (flags &gt;= 0)
      fcntl(fds[target], F_SETFD, flags & ~FD_CLOEXEC);
  }
  return stream;
}
</tt></pre>
<p>Both examples can share a common <a href="../functions/pclose.html"><i>pclose</i>()</a> implementation.</p>
<pre>
<tt>int pclose(FILE *stream)
{
  int status;
  popen_lock();
  pid_t pid = popen_get_pid(stream);
  if (pid &lt; 0) {
    popen_unlock();
    return -1;
  }
  popen_remove(stream);
  popen_unlock();
  fclose(stream); /* Ignore failure */
  while (waitpid(pid, &amp;status, 0) == -1) {
    if (errno != EINTR) {
      status = -1;
      break;
    }
  }
  return status;
}
</tt></pre>
<p>Note that, while a particular implementation of <i>popen</i>() (such as the two above) can assume a particular path for the
shell, such a path is not necessarily valid on another system. The above examples are not portable, and are not intended to be.</p>
<p>Earlier versions of this standard required the <i>command</i> string to be passed as the next argument after <tt>"-c"</tt>
(omitting <tt>"--"</tt>). This meant that portable applications needed to take care not to pass a command string beginning with
&lt;hyphen-minus&gt; (<tt>'-'</tt>) or &lt;plus-sign&gt; (<tt>'+'</tt>), as it would then be interpreted as containing options. Now
that implementations are required to pass the <tt>"--"</tt>, applications no longer need to do this.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_379_09" id="tag_17_379_09"></a>FUTURE DIRECTIONS</h4>
<blockquote>
<p>None.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_379_10" id="tag_17_379_10"></a>SEE ALSO</h4>
<blockquote>
<p><a href="../functions/V2_chap02.html#tag_16_05"><i>2.5 Standard I/O Streams</i></a>, <a href=
"../functions/fork.html#"><i>fork</i>()</a>, <a href="../functions/pclose.html#"><i>pclose</i>()</a>, <a href=
"../functions/pipe.html#"><i>pipe</i>()</a>, <a href="../functions/sysconf.html#"><i>sysconf</i>()</a>, <a href=
"../functions/system.html#"><i>system</i>()</a>, <a href="../functions/wait.html#tag_17_658"><i>wait</i>()</a>, <a href=
"../functions/waitid.html#"><i>waitid</i>()</a></p>
<p>XBD <a href="../basedefs/stdio.h.html"><i>&lt;stdio.h&gt;</i></a></p>
<p>XCU <a href="../utilities/sh.html#"><i>sh</i></a></p>
</blockquote>
<h4 class="mansect"><a name="tag_17_379_11" id="tag_17_379_11"></a>CHANGE HISTORY</h4>
<blockquote>
<p>First released in Issue 1. Derived from Issue 1 of the SVID.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_379_12" id="tag_17_379_12"></a>Issue 5</h4>
<blockquote>
<p>A statement is added to the DESCRIPTION indicating that pipe streams are byte-oriented.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_379_13" id="tag_17_379_13"></a>Issue 6</h4>
<blockquote>
<p>The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:</p>
<ul>
<li>
<p>The optional [EMFILE] error condition is added.</p>
</li>
</ul>
<p>IEEE&nbsp;Std&nbsp;1003.1-2001/Cor&nbsp;2-2004, item XSH/TC2/D6/67 is applied, adding the example to the EXAMPLES section.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_379_14" id="tag_17_379_14"></a>Issue 7</h4>
<blockquote>
<p>Austin Group Interpretation 1003.1-2001 #029 is applied, clarifying the values for <i>mode</i> in the DESCRIPTION.</p>
<p>SD5-XSH-ERN-149 is applied, changing the {STREAM_MAX} [EMFILE] error condition from a &quot;may fail&quot; to a &quot;shall fail&quot;.</p>
<p>POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0432 [14] is applied.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_379_15" id="tag_17_379_15"></a>Issue 8</h4>
<blockquote>
<p>Austin Group Defects 411 and 1318 are applied, adding the <tt>'e'</tt> mode modifier and FD_CLOFORK, and adding example
implementations of <i>popen</i>() and <a href="../functions/pclose.html"><i>pclose</i>()</a> in the RATIONALE section.</p>
<p>Austin Group Defect 1317 is applied, making it implementation-defined whether the handlers registered with <a href=
"../functions/pthread_atfork.html"><i>pthread_atfork</i>()</a> are called.</p>
<p>Austin Group Defect 1440 is applied, adding a <tt>"--"</tt> argument to the specified <a href=
"../functions/execl.html"><i>execl</i>()</a> call.</p>
<p>Austin Group Defect 1526 is applied, making typographic changes relating to <i>mode</i> values for consistency with <a href=
"../functions/fopen.html"><i>fopen</i>()</a>.</p>
</blockquote>
<div class="box"><em>End of informative text.</em></div>
<hr>
<p>&nbsp;</p>
<a href="#top"><span class="topOfPage">return to top of page</span></a><br>
<hr size="2" noshade>
<center><font size="2">UNIX® is a registered Trademark of The Open Group.<br>
POSIX™ is a Trademark of The IEEE.<br>
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved<br>
[ <a href="../mindex.html">Main Index</a> | <a href="../basedefs/contents.html">XBD</a> | <a href=
"../functions/contents.html">XSH</a> | <a href="../utilities/contents.html">XCU</a> | <a href="../xrat/contents.html">XRAT</a>
]</font></center>
<hr size="2" noshade>
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/poll.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/posix_devctl.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>
<hr align="left" width="100%"></div>
</body>
</html>
