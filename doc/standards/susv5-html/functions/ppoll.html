<!-- Copyright 2001-2024 IEEE and The Open Group, All Rights Reserved -->
<!DOCTYPE HTML>
<html lang="en">
<head>
<meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.8.0">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link type="text/css" rel="stylesheet" href="style.css"><!-- Generated by The Open Group rhtm tool v1.2.4 -->
<!-- Copyright (c) 2001-2024 The Open Group, All Rights Reserved -->
<title>poll</title>
</head>
<body bgcolor="white">
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/pipe.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/popen.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>
<hr align="left" width="100%"></div>
<center><font size="2">The Open Group Base Specifications Issue 8<br>
IEEE Std 1003.1-2024<br>
Copyright © 2001-2024 The IEEE and The Open Group</font></center>
<hr size="2" noshade>
<a name="top" id="top"></a> <a name="poll" id="poll"></a> <a name="tag_17_378" id="tag_17_378"></a><!-- poll -->
<h4 class="mansect"><a name="tag_17_378_01" id="tag_17_378_01"></a>NAME</h4>
<blockquote>poll, ppoll — input/output multiplexing</blockquote>
<h4 class="mansect"><a name="tag_17_378_02" id="tag_17_378_02"></a>SYNOPSIS</h4>
<blockquote class="synopsis">
<p><code><tt>#include &lt;<a href="../basedefs/poll.h.html">poll.h</a>&gt;<br>
<br>
int poll(struct pollfd</tt> <i>fds</i><tt>[], nfds_t</tt> <i>nfds</i><tt>, int</tt> <i>timeout</i><tt>);<br>
int ppoll(struct pollfd</tt> <i>fds[]</i><tt>, nfds_t</tt> <i>nfds</i><tt>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct timespec *restrict</tt> <i>timeout</i><tt>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const sigset_t *restrict</tt> <i>sigmask</i><tt>);<br></tt></code></p>
</blockquote>
<h4 class="mansect"><a name="tag_17_378_03" id="tag_17_378_03"></a>DESCRIPTION</h4>
<blockquote>
<p>The <i>ppoll</i>() function provides applications with a mechanism for multiplexing input/output over a set of file descriptors.
For each member of the array pointed to by <i>fds</i>, <i>ppoll</i>() shall examine the given file descriptor for the event(s)
specified in <i>events</i>. The number of <b>pollfd</b> structures in the <i>fds</i> array is specified by <i>nfds</i>. The
<i>ppoll</i>() function shall identify those file descriptors on which an application can make an attempt to read or write data
without blocking, or on which certain events have occurred.</p>
<p>The <i>poll</i>() function shall be equivalent to the <i>ppoll</i>() function, except as follows:</p>
<ul>
<li>
<p>For the <i>poll</i>() function, the timeout period is given in milliseconds in an argument of type <b>int</b>, whereas for the
<i>ppoll</i>() function the timeout period is given in seconds and nanoseconds via an argument of type pointer to <b>struct
timespec</b>. A <i>timeout</i> of -1 for <i>poll</i>() shall be equivalent to passing a null pointer for the <i>timeout</i> for
<i>ppoll</i>().</p>
</li>
<li>
<p>The <i>poll</i>() function has no <i>sigmask</i> argument; it shall behave as <i>ppoll</i>() does when <i>sigmask</i> is a null
pointer.</p>
</li>
</ul>
<p>The <i>fds</i> argument specifies the file descriptors to be examined and the events of interest for each file descriptor. It is
a pointer to an array with one member for each open file descriptor of interest. The array's members are <b>pollfd</b> structures
within which <i>fd</i> specifies an open file descriptor and <i>events</i> and <i>revents</i> are bitmasks constructed by OR'ing a
combination of the following event flags:</p>
<dl compact>
<dd></dd>
<dt>POLLIN</dt>
<dd>The file descriptor is ready for reading data other than high-priority data.</dd>
<dt>POLLRDNORM</dt>
<dd>The file descriptor is ready for reading normal data.</dd>
<dt>POLLRDBAND</dt>
<dd>The file descriptor is ready for reading priority data.</dd>
<dt>POLLPRI</dt>
<dd>The file descriptor is ready for reading high-priority data.</dd>
<dt>POLLOUT</dt>
<dd>The file descriptor is ready for writing normal data.</dd>
<dt>POLLWRNORM</dt>
<dd>Equivalent to POLLOUT.</dd>
<dt>POLLWRBAND</dt>
<dd>The file descriptor is ready for writing priority data.</dd>
<dt>POLLERR</dt>
<dd>An error condition is present on the file descriptor. All error conditions that arise solely from the state of the object
underlying the open file description and would be diagnosed by a return of -1 from a <a href=
"../functions/read.html"><i>read</i>()</a> or <a href="../functions/write.html"><i>write</i>()</a> call on the file descriptor
shall be reported as a POLLERR event. This flag is only valid in the <i>revents</i> bitmask; it shall be ignored in the
<i>events</i> member.</dd>
<dt>POLLHUP</dt>
<dd>A device has been disconnected, or a pipe or FIFO has been closed by the last process that had it open for writing. Once set,
the hangup state of a FIFO shall persist until some process opens the FIFO for writing or until all read-only file descriptors for
the FIFO are closed. This event and POLLOUT are mutually-exclusive. However, this event and POLLIN, POLLRDNORM, POLLRDBAND, or
POLLPRI are not mutually-exclusive. This flag is only valid in the <i>revents</i> bitmask; it shall be ignored in the <i>events</i>
member.</dd>
<dt>POLLNVAL</dt>
<dd>The specified <i>fd</i> value is not an open file descriptor. This flag is only valid in the <i>revents</i> member; it shall be
ignored in the <i>events</i> member.</dd>
</dl>
<p>A file descriptor shall be considered ready for reading when a call to an input function with O_NONBLOCK clear would not block,
whether or not the function would transfer data successfully. (The function might return data, an end-of-file indication, or an
error other than one indicating that it is blocked, and in each of these cases the descriptor is considered ready for reading.) A
file descriptor shall be considered ready for writing when a call to an output function with O_NONBLOCK clear would not block,
whether or not the function would transfer data successfully. How much data could be written without blocking depends upon the
object underlying the open file description and its current state.</p>
<p>The significance and semantics of normal, priority, and high-priority data are file and device-specific. The semantics of device
disconnection are device-specific.</p>
<p>If the value of <i>fd</i> is less than 0, <i>events</i> shall be ignored, and <i>revents</i> shall be set to 0 in that entry on
return from <i>poll</i>() or <i>ppoll</i>().</p>
<p>In each <b>pollfd</b> structure, <i>poll</i>() or <i>ppoll</i>() shall clear the <i>revents</i> member, except that where the
application requested a report on a condition by setting one of the bits of <i>events</i> listed above, <i>poll</i>() or
<i>ppoll</i>() shall set the corresponding bit in <i>revents</i> if the requested condition is true. In addition, <i>poll</i>() or
<i>ppoll</i>() shall set the POLLHUP, POLLERR, and POLLNVAL flag in <i>revents</i> if the condition is true, even if the
application did not set the corresponding bit in <i>events</i>.</p>
<p>The <i>timeout</i> argument controls how long the <i>poll</i>() or <i>ppoll</i>() function shall wait before timing out. If the
<i>timeout</i> argument is positive for <i>poll</i>() or not a null pointer for <i>ppoll</i>(), it specifies a maximum interval to
wait for the poll to complete. If the specified time interval expires without any of the defined events having occurred, the
function shall return. If the <i>timeout</i> argument is -1 for <i>poll</i>() or a null pointer for <i>ppoll</i>(), then the call
shall block indefinitely until at least one descriptor meets the specified criteria or until the call is interrupted. To effect a
poll, the application shall ensure that the <i>timeout</i> argument for <i>poll</i>() is 0, or for <i>ppoll</i>() is not a null
pointer and points to a zero-valued <b>timespec</b> structure.</p>
<p>Implementations may place limitations on the maximum timeout interval supported. All implementations shall support a maximum
timeout interval of at least 31 days for <i>ppoll</i>(). If the <i>timeout</i> argument specifies a timeout interval greater than
the implementation-defined maximum value, the maximum value shall be used as the actual timeout value. Implementations may also
place limitations on the granularity of timeout intervals. If the requested timeout interval requires a finer granularity than the
implementation supports, the actual timeout interval shall be rounded up to the next supported value.</p>
<p>The <i>poll</i>() and <i>ppoll</i>() functions shall not be affected by the O_NONBLOCK flag.</p>
<p>The <i>poll</i>() and <i>ppoll</i>() functions shall support regular files, terminal and pseudo-terminal devices, FIFOs, pipes,
and sockets. The behavior of <i>poll</i>() and <i>ppoll</i>() on elements of <i>fds</i> that refer to other types of file is
unspecified.</p>
<p>Regular files shall always poll TRUE for reading and writing.</p>
<p>A file descriptor for a socket that is listening for connections shall indicate that it is ready for reading, once connections
are available. A file descriptor for a socket that is connecting asynchronously shall indicate that it is ready for writing, once a
connection has been established.</p>
<p>Provided the application does not perform any action that results in unspecified or undefined behavior, the value of the
<i>fd</i> and <i>events</i> members of each element of <i>fds</i> shall not be modified by <i>poll</i>() or <i>ppoll</i>().</p>
<p>If <i>sigmask</i> is not a null pointer, the <i>ppoll</i>() function shall replace the signal mask of the caller by the set of
signals pointed to by <i>sigmask</i> before examining the descriptors, and shall restore the signal mask of the calling thread
before returning. If a signal is unmasked as a result of the signal mask being altered by <i>ppoll</i>(), and a signal-catching
function is called for that signal during the execution of the <i>ppoll</i>() function, and SA_RESTART is clear for the
interrupting signal, then</p>
<ul>
<li>
<p>If none of the defined events have occurred on any selected file descriptor, <i>ppoll</i>() shall immediately fail with the
[EINTR] error after the signal-catching function returns.</p>
</li>
<li>
<p>If one or more of the defined events have occurred, it is unspecified whether <i>ppoll</i>() behaves the same as if none of the
events had occurred (failing with [EINTR] as above) or behaves the same as if it was not interrupted (returning the total number of
<b>pollfd</b> structures that have selected events).</p>
</li>
</ul>
<p>If a thread is canceled during a <i>ppoll</i>() call, it is unspecified whether the signal mask in effect when executing the
registered cleanup functions is the original signal mask or the signal mask installed as part of the <i>ppoll</i>() call.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_378_04" id="tag_17_378_04"></a>RETURN VALUE</h4>
<blockquote>
<p>Upon successful completion, a non-negative value shall be returned. A positive value shall indicate the total number of
<b>pollfd</b> structures that have selected events (that is, those for which the <i>revents</i> member is non-zero). A value of 0
shall indicate that the call timed out and no file descriptors have been selected. Upon failure, -1 shall be returned and
<i>errno</i> set to indicate the error.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_378_05" id="tag_17_378_05"></a>ERRORS</h4>
<blockquote>
<p>The <i>poll</i>() and <i>ppoll</i>() functions shall fail if:</p>
<dl compact>
<dd></dd>
<dt>[EAGAIN]</dt>
<dd>The allocation of internal data structures failed but a subsequent request may succeed.</dd>
<dt>[EINTR]</dt>
<dd>A signal was caught during <i>poll</i>() or <i>ppoll</i>().</dd>
<dt>[EINVAL]</dt>
<dd>The <i>nfds</i> argument is greater than {OPEN_MAX}.</dd>
</dl>
<p>The <i>ppoll</i>() function shall fail if:</p>
<dl compact>
<dd></dd>
<dt>[EINVAL]</dt>
<dd>An invalid timeout interval was specified.</dd>
</dl>
</blockquote>
<hr>
<div class="box"><em>The following sections are informative.</em></div>
<h4 class="mansect"><a name="tag_17_378_06" id="tag_17_378_06"></a>EXAMPLES</h4>
<blockquote>
<p>None.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_378_07" id="tag_17_378_07"></a>APPLICATION USAGE</h4>
<blockquote>
<p>Other than the difference in the precision of the requested timeout, the following <i>ppoll</i>() call:</p>
<pre>
<tt>ready = ppoll(&amp;fds, nfds, tmo_p, &amp;sigmask);
</tt></pre>
<p>is equivalent to atomically executing the following calls:</p>
<pre>
<tt>sigset_t origmask;
int timeout;
<br>
timeout = (tmo_p == NULL) ? -1 :
    (tmo_p-&gt;tv_sec * 1000 + tmo_p-&gt;tv_nsec / 1000000);
pthread_sigmask(SIG_SETMASK, &amp;sigmask, &amp;origmask);
ready = poll(&amp;fds, nfds, timeout);
pthread_sigmask(SIG_SETMASK, &amp;origmask, NULL);
</tt></pre>
<p>When a <i>poll</i>() or <i>ppoll</i>() call indicates a file descriptor is ready for reading, this means that if an attempt to
read data had been made at the time that the status of the file descriptor was checked, it would have returned at least one byte of
data, an end-of-file indication, or an error, without blocking (even if O_NONBLOCK is clear). When a <i>poll</i>() or
<i>ppoll</i>() call indicates that a file descriptor is ready for writing, this means that if an attempt to write one byte of data
had been made at the time that the status of the file descriptor was checked, it would have written that byte or returned an error,
without blocking. However, if an attempt to write more than one byte had been made, it might have blocked (if O_NONBLOCK is clear).
In both cases, by the time the call returns and a subsequent I/O operation is attempted, the state of the file descriptor might
have changed (for example, because another thread read or wrote some data) and, if O_NONBLOCK is clear, there is no guarantee that
the operation will not block (unless it would not block for some other reason, such as setting MIN=0 and TIME=0 for a terminal in
non-canonical mode). Therefore it is recommended that applications always set O_NONBLOCK on file descriptors whose readiness for
I/O they query with <i>poll</i>() or <i>ppoll</i>().</p>
<p>The error conditions specified for <a href="../functions/read.html"><i>read</i>()</a> and <a href=
"../functions/write.html"><i>write</i>()</a> that are reported as POLLERR events are only those that arise solely from the state of
the object underlying the open file description. They do not include, for example, [EAGAIN] as this relates to the state of the
open file description not (solely) the object underlying it.</p>
<p>Application writers should note that repeating a <i>poll</i>() or <i>ppoll</i>() call which indicated that I/O was possible on
one or more of the file descriptors given, without causing some change to the state, either by altering the <i>fds</i> array or
causing appropriate input or output to occur on at least one file descriptor indicated as ready, will result in &quot;busy waiting&quot;—a
subsequent call will always return immediately indicating the same (or perhaps more) events as the previous one.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_378_08" id="tag_17_378_08"></a>RATIONALE</h4>
<blockquote>
<p>The POLLHUP event does not occur for FIFOs just because the FIFO is not open for writing. It only occurs when the FIFO is closed
by the last writer and persists until some process opens the FIFO for writing or until all read-only file descriptors for the FIFO
are closed.</p>
<p>Code which wants to avoid the ambiguity of the signal mask for thread cancellation handlers can install an additional
cancellation handler which resets the signal mask to the expected value:</p>
<pre>
<tt>void cleanup(void *arg)
{
    sigset_t *ss = (sigset_t *) arg;
    pthread_sigmask(SIG_SETMASK, ss, NULL);
}
int call_ppoll(struct pollfd fds[], nfds_t nfds,
    const struct timespec *restrict timeout,
    const sigset_t *restrict sigmask)
{
    sigset_t oldmask;
    int result;
    pthread_sigmask(SIG_SETMASK, NULL, &amp;oldmask);
    pthread_cleanup_push(cleanup, &amp;oldmask);
    result = ppoll(fds, nfds, timeout, sigmask);
    pthread_cleanup_pop(0);
    return result;
}
</tt></pre></blockquote>
<h4 class="mansect"><a name="tag_17_378_09" id="tag_17_378_09"></a>FUTURE DIRECTIONS</h4>
<blockquote>
<p>None.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_378_10" id="tag_17_378_10"></a>SEE ALSO</h4>
<blockquote>
<p><a href="../functions/pselect.html#"><i>pselect</i>()</a>, <a href="../functions/read.html#tag_17_476"><i>read</i>()</a>,
<a href="../functions/write.html#tag_17_699"><i>write</i>()</a></p>
<p>XBD <a href="../basedefs/poll.h.html"><i>&lt;poll.h&gt;</i></a></p>
</blockquote>
<h4 class="mansect"><a name="tag_17_378_11" id="tag_17_378_11"></a>CHANGE HISTORY</h4>
<blockquote>
<p>First released in Issue 4, Version 2.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_378_12" id="tag_17_378_12"></a>Issue 5</h4>
<blockquote>
<p>Moved from X/OPEN UNIX extension to BASE.</p>
<p>The description of POLLWRBAND is updated.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_378_13" id="tag_17_378_13"></a>Issue 6</h4>
<blockquote>
<p>Text referring to sockets is added to the DESCRIPTION.</p>
<p>Functionality relating to the XSI STREAMS Option Group is marked.</p>
<p>The Open Group Corrigendum U055/3 is applied, updating the DESCRIPTION of POLLWRBAND.</p>
<p>IEEE&nbsp;Std&nbsp;1003.1-2001/Cor&nbsp;2-2004, item XSH/TC2/D6/66 is applied, correcting the spacing in the EXAMPLES
section.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_378_14" id="tag_17_378_14"></a>Issue 7</h4>
<blockquote>
<p>Austin Group Interpretation 1003.1-2001 #209 is applied, clarifying the POLLHUP event.</p>
<p>The <i>poll</i>() function is moved from the XSI option to the Base.</p>
<p>Functionality relating to the XSI STREAMS option is marked obsolescent.</p>
<p>POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0249 [623] and XSH/TC2-2008/0250 [683] are applied.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_378_15" id="tag_17_378_15"></a>Issue 8</h4>
<blockquote>
<p>Austin Group Defect 1263 is applied, adding <i>ppoll</i>().</p>
<p>Austin Group Defect 1330 is applied, removing obsolescent interfaces.</p>
<p>Austin Group Defect 1448 is applied, aligning the wording relating to file descriptor readiness with <a href=
"../functions/pselect.html"><i>pselect</i>()</a> and changing the APPLICATION USAGE section.</p>
</blockquote>
<div class="box"><em>End of informative text.</em></div>
<hr>
<p>&nbsp;</p>
<a href="#top"><span class="topOfPage">return to top of page</span></a><br>
<hr size="2" noshade>
<center><font size="2">UNIX® is a registered Trademark of The Open Group.<br>
POSIX™ is a Trademark of The IEEE.<br>
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved<br>
[ <a href="../mindex.html">Main Index</a> | <a href="../basedefs/contents.html">XBD</a> | <a href=
"../functions/contents.html">XSH</a> | <a href="../utilities/contents.html">XCU</a> | <a href="../xrat/contents.html">XRAT</a>
]</font></center>
<hr size="2" noshade>
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/pipe.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/popen.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>
<hr align="left" width="100%"></div>
</body>
</html>
