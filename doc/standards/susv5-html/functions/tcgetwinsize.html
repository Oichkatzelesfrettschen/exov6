<!-- Copyright 2001-2024 IEEE and The Open Group, All Rights Reserved -->
<!DOCTYPE HTML>
<html lang="en">
<head>
<meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.8.0">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link type="text/css" rel="stylesheet" href="style.css"><!-- Generated by The Open Group rhtm tool v1.2.4 -->
<!-- Copyright (c) 2001-2024 The Open Group, All Rights Reserved -->
<title>tcgetwinsize</title>
</head>
<body bgcolor="white">
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/tcgetsid.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/tcsendbreak.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>
<hr align="left" width="100%"></div>
<center><font size="2">The Open Group Base Specifications Issue 8<br>
IEEE Std 1003.1-2024<br>
Copyright © 2001-2024 The IEEE and The Open Group</font></center>
<hr size="2" noshade>
<a name="top" id="top"></a> <a name="tcgetwinsize" id="tcgetwinsize"></a> <a name="tag_17_609" id="tag_17_609"></a>
<!-- tcgetwinsize -->
<h4 class="mansect"><a name="tag_17_609_01" id="tag_17_609_01"></a>NAME</h4>
<blockquote>tcgetwinsize — get the size of a terminal window</blockquote>
<h4 class="mansect"><a name="tag_17_609_02" id="tag_17_609_02"></a>SYNOPSIS</h4>
<blockquote class="synopsis">
<p><code><tt>#include &lt;<a href="../basedefs/termios.h.html">termios.h</a>&gt;<br>
<br>
int tcgetwinsize(int</tt> <i>fildes</i><tt>, struct winsize *</tt><i>winsize_p</i><tt>);<br></tt></code></p>
</blockquote>
<h4 class="mansect"><a name="tag_17_609_03" id="tag_17_609_03"></a>DESCRIPTION</h4>
<blockquote>
<p>The <i>tcgetwinsize</i>() function shall get the terminal window size associated with the terminal referred to by <i>fildes</i>
and store it in the <b>winsize</b> structure pointed to by <i>winsize_p</i>. The <i>fildes</i> argument is an open file descriptor
associated with a terminal. The <i>winsize_p</i> argument is a pointer to a <b>winsize</b> structure.</p>
<p>If the terminal referred to by <i>fildes</i> was opened without O_TTY_INIT and is not a pseudo-terminal, and the terminal window
size has not been set by a call to <a href="../functions/tcsetwinsize.html"><i>tcsetwinsize</i>()</a>, the terminal window size is
unspecified.</p>
<p>If the terminal was opened with O_TTY_INIT or is a pseudo-terminal, and the terminal window size has not been set by a call to
<a href="../functions/tcsetwinsize.html"><i>tcsetwinsize</i>()</a>, the terminal window size shall be set to an appropriate default
(see <a href="../functions/open.html#"><i>open</i>()</a>).</p>
<p>If the terminal window size has been set by a call to <a href="../functions/tcsetwinsize.html"><i>tcsetwinsize</i>()</a>, the
values set by that call shall be returned.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_609_04" id="tag_17_609_04"></a>RETURN VALUE</h4>
<blockquote>
<p>Upon successful completion, 0 shall be returned. Otherwise, -1 shall be returned and <i>errno</i> set to indicate the error.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_609_05" id="tag_17_609_05"></a>ERRORS</h4>
<blockquote>
<p>The <i>tcgetwinsize</i>() function shall fail if:</p>
<dl compact>
<dd></dd>
<dt>[EBADF]</dt>
<dd>The <i>fildes</i> argument is not a valid file descriptor.</dd>
<dt>[ENOTTY]</dt>
<dd>The file associated with <i>fildes</i> is not a terminal.</dd>
</dl>
</blockquote>
<hr>
<div class="box"><em>The following sections are informative.</em></div>
<h4 class="mansect"><a name="tag_17_609_06" id="tag_17_609_06"></a>EXAMPLES</h4>
<blockquote>
<pre>
<tt>#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;signal.h&gt;
#include &lt;termios.h&gt;
#include &lt;unistd.h&gt;

static volatile sig_atomic_t vrow;
static volatile sig_atomic_t vcol;
static volatile sig_atomic_t newsize;

static void winch_handler(int signum)
{
    struct winsize ws;
    int sav_errno = errno;

    (void)signum; // prevent compiler warning that signum is unused

    // set volatile vars to new winsize, or 0 if unavailable or
    // too large

    if (tcgetwinsize(STDERR_FILENO, &amp;ws) == -1)
    {
        vrow = vcol = 0;
    }
    else
    {
        if (ws.ws_row &lt;= SIG_ATOMIC_MAX &amp;& ws.ws_col &lt;= SIG_ATOMIC_MAX)
        {
            vrow = ws.ws_row;
            vcol = ws.ws_col;
        }
        else
        {
            vrow = vcol = 0;
        }
    }

    newsize = 1;

    errno = sav_errno;
}

int main(void)
{
    struct sigaction sa;
    struct winsize ws;
    sigset_t winch_set;
    char inbuf[512];

    sa.sa_handler = winch_handler;
    sigemptyset(&amp;sa.sa_mask);
    sa.sa_flags = 0;
    sigaction(SIGWINCH, &amp;sa, NULL);

    sigemptyset(&amp;winch_set);
    sigaddset(&amp;winch_set, SIGWINCH);

    raise(SIGWINCH); // gets the initial winsize

    for (;;)
    {
        if (fgets(inbuf, sizeof inbuf, stdin) == NULL)
        {
            if (feof(stdin))
                exit(0);
            else if (errno == EINTR)
                continue;
            else
            {
                perror("Error reading stdin");
                exit(1);
            }
        }
        else
        {
            if (newsize)
            {
                // prevent updates to volatile vars while we read them
                sigprocmask(SIG_BLOCK, &amp;winch_set, NULL);
                ws.ws_row = vrow;
                ws.ws_col = vcol;
                sigprocmask(SIG_UNBLOCK, &amp;winch_set, NULL);
                newsize = 0;
            }
            printf("row = %3hu, col = %3hu\n", ws.ws_row, ws.ws_col);

            // process inbuf ...
        }
    }
}
</tt></pre></blockquote>
<h4 class="mansect"><a name="tag_17_609_07" id="tag_17_609_07"></a>APPLICATION USAGE</h4>
<blockquote>
<p>Applications should take care to avoid race conditions and other undefined behavior when calling <i>tcgetwinsize</i>() from
signal handlers. A common but incorrect idiom is to establish a signal handler for SIGWINCH from which <i>tcgetwinsize</i>() is
called to update a global <b>winsize</b> structure. This usage is incorrect as accessing a <b>winsize</b> structure is not
guaranteed to be an atomic operation. Instead, applications should have <i>tcgetwinsize</i>() write to a local structure and copy
each member the application is interested in to a global variable of type <b>volatile sig_atomic_t</b>. Furthermore, SIGWINCH
should be blocked from delivery while the terminal size is read from these global variables to further avoid race conditions. A
simpler alternative, if the application is structured in a suitable way, is just to set a flag in the signal handler and then call
<i>tcgetwinsize</i>() (and clear the flag) at an appropriate place in the code if the flag has been set.</p>
<p>Multi-threaded applications should avoid the signal handler idiom in general. Instead, it is advised to use <a href=
"../functions/sigwait.html"><i>sigwait</i>()</a> to wait for the delivery of a SIGWINCH signal.</p>
<p>If the terminal window size changes while a process is in the background, it is not notified via SIGWINCH (which is sent only to
the foreground process group). Applications can handle this case by calling <i>tcgetwinsize</i>() if the process receives SIGCONT,
to check whether the terminal window size changed while the process was stopped.</p>
<p>If a background process writes to a terminal and the TOSTOP flag is clear (see XBD <a href=
"../basedefs/V1_chap11.html#tag_11_02_05"><i>11.2.5 Local Modes</i></a>), the process might not receive SIGTTOU or SIGWINCH
signals and thus might not be notified when the terminal window size might have changed. Such processes must periodically poll the
current terminal window size if needed.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_609_08" id="tag_17_609_08"></a>RATIONALE</h4>
<blockquote>
<p>The <i>tcgetwinsize</i>() function is provided to allow applications to query the current terminal window size. This is
necessary for applications intended to be run in terminals whose terminal window size can be changed at runtime. Conventionally, a
SIGWINCH signal is delivered to a controlling terminal's foreground process group whenever its terminal window size is changed. By
installing a signal handler for SIGWINCH, a process can detect the change to the controlling terminal's window size and take
action, e.g. by redrawing its user interface to the new size.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_609_09" id="tag_17_609_09"></a>FUTURE DIRECTIONS</h4>
<blockquote>
<p>None.</p>
</blockquote>
<h4 class="mansect"><a name="tag_17_609_10" id="tag_17_609_10"></a>SEE ALSO</h4>
<blockquote>
<p><a href="../functions/tcsetwinsize.html#"><i>tcsetwinsize</i>()</a></p>
<p>XBD <a href="../basedefs/termios.h.html"><i>&lt;termios.h&gt;</i></a></p>
</blockquote>
<h4 class="mansect"><a name="tag_17_609_11" id="tag_17_609_11"></a>CHANGE HISTORY</h4>
<blockquote>
<p>First released in Issue 8.</p>
</blockquote>
<div class="box"><em>End of informative text.</em></div>
<hr>
<p>&nbsp;</p>
<a href="#top"><span class="topOfPage">return to top of page</span></a><br>
<hr size="2" noshade>
<center><font size="2">UNIX® is a registered Trademark of The Open Group.<br>
POSIX™ is a Trademark of The IEEE.<br>
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved<br>
[ <a href="../mindex.html">Main Index</a> | <a href="../basedefs/contents.html">XBD</a> | <a href=
"../functions/contents.html">XSH</a> | <a href="../utilities/contents.html">XCU</a> | <a href="../xrat/contents.html">XRAT</a>
]</font></center>
<hr size="2" noshade>
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/tcgetsid.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/tcsendbreak.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>
<hr align="left" width="100%"></div>
</body>
</html>
